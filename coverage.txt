/Users/garthdb/Projects/rust-things/apps/things-cli/src/main.rs:
    1|       |//! Things CLI - Command line interface for Things 3 with integrated MCP server
    2|       |
    3|       |use things_cli::mcp;
    4|       |
    5|       |use clap::{Parser, Subcommand};
    6|       |use std::path::PathBuf;
    7|       |use things_core::{Result, ThingsConfig, ThingsDatabase};
    8|       |
    9|       |#[derive(Parser, Debug)]
   10|       |#[command(name = "things-cli")]
   11|       |#[command(about = "Things 3 CLI with integrated MCP server")]
   12|       |#[command(version)]
   13|       |struct Cli {
   14|       |    /// Database path (defaults to Things 3 default location)
   15|       |    #[arg(long, short)]
   16|       |    database: Option<PathBuf>,
   17|       |
   18|       |    /// Fall back to default database path if specified path doesn't exist
   19|       |    #[arg(long)]
   20|       |    fallback_to_default: bool,
   21|       |
   22|       |    /// Enable verbose output
   23|       |    #[arg(long, short)]
   24|       |    verbose: bool,
   25|       |
   26|       |    #[command(subcommand)]
   27|       |    command: Commands,
   28|       |}
   29|       |
   30|       |#[derive(Subcommand, Debug)]
   31|       |enum Commands {
   32|       |    /// Show inbox tasks
   33|       |    Inbox {
   34|       |        /// Limit number of results
   35|       |        #[arg(long, short)]
   36|       |        limit: Option<usize>,
   37|       |    },
   38|       |    /// Show today's tasks
   39|       |    Today {
   40|       |        /// Limit number of results
   41|       |        #[arg(long, short)]
   42|       |        limit: Option<usize>,
   43|       |    },
   44|       |    /// Show all projects
   45|       |    Projects {
   46|       |        /// Filter by area UUID
   47|       |        #[arg(long)]
   48|       |        area: Option<String>,
   49|       |    },
   50|       |    /// Show all areas
   51|       |    Areas,
   52|       |    /// Search for tasks
   53|       |    Search {
   54|       |        /// Search query
   55|       |        query: String,
   56|       |        /// Limit number of results
   57|       |        #[arg(long, short)]
   58|       |        limit: Option<usize>,
   59|       |    },
   60|       |    /// Start MCP server mode
   61|       |    Mcp,
   62|       |    /// Health check
   63|       |    Health,
   64|       |}
   65|       |
   66|       |#[tokio::main]
   67|      0|async fn main() -> Result<()> {
   68|      0|    let cli = Cli::parse();
   69|       |
   70|       |    // Set up logging if verbose
   71|      0|    if cli.verbose {
   72|      0|        env_logger::Builder::from_default_env()
   73|      0|            .filter_level(log::LevelFilter::Debug)
   74|      0|            .init();
   75|      0|    }
   76|       |
   77|       |    // Create configuration
   78|      0|    let config = if let Some(db_path) = cli.database {
   79|      0|        ThingsConfig::new(db_path, cli.fallback_to_default)
   80|       |    } else {
   81|      0|        ThingsConfig::from_env()
   82|       |    };
   83|       |
   84|       |    // Create database connection
   85|      0|    let db = ThingsDatabase::with_config(&config)?;
   86|       |
   87|      0|    match cli.command {
   88|      0|        Commands::Inbox { limit } => {
   89|      0|            let tasks = db.get_inbox(limit)?;
   90|      0|            print_tasks(&tasks);
   91|      0|        }
   92|      0|        Commands::Today { limit } => {
   93|      0|            let tasks = db.get_today(limit)?;
   94|      0|            print_tasks(&tasks);
   95|      0|        }
   96|      0|        Commands::Projects { area } => {
   97|      0|            let area_uuid = area.and_then(|a| uuid::Uuid::parse_str(&a).ok());
   98|      0|            let projects = db.get_projects(area_uuid)?;
   99|      0|            print_projects(&projects);
  100|      0|        }
  101|      0|        Commands::Areas => {
  102|      0|            let areas = db.get_areas()?;
  103|      0|            print_areas(&areas);
  104|      0|        }
  105|      0|        Commands::Search { query, limit } => {
  106|      0|            let tasks = db.search_tasks(&query, limit)?;
  107|      0|            print_tasks(&tasks);
  108|      0|        }
  109|      0|        Commands::Mcp => {
  110|      0|            println!("ðŸš€ Starting Things 3 MCP server...");
  111|      0|            println!("ðŸ“¡ Server will be available for AI/LLM integration");
  112|      0|            println!("ðŸ› ï¸  Available tools: get_inbox, get_today, get_projects, get_areas, search_tasks, create_task, update_task, get_productivity_metrics, export_data, bulk_create_tasks, get_recent_tasks, backup_database, restore_database, list_backups, get_performance_stats, get_system_metrics, get_cache_stats");
  113|      0|            println!();
  114|      0|
  115|      0|            // Start MCP server
  116|      0|            let mcp_server = mcp::ThingsMcpServer::new(db, config);
  117|      0|            start_mcp_server(mcp_server).await?;
  118|      0|        }
  119|      0|        Commands::Health => {
  120|      0|            health_check(&db)?;
  121|      0|        }
  122|      0|    }
  123|      0|
  124|      0|    Ok(())
  125|      0|}
  126|       |
  127|      3|fn print_tasks(tasks: &[things_core::Task]) {
  128|      3|    if tasks.is_empty() {
  129|      1|        println!("No tasks found");
  130|      1|        return;
  131|      2|    }
  132|       |
  133|      2|    println!("Found {} tasks:", tasks.len());
  134|      5|    for task in tasks {
                      ^3
  135|      3|        println!("  â€¢ {} ({:?})", task.title, task.task_type);
  136|      3|        if let Some(notes) = &task.notes {
  137|      3|            println!("    Notes: {notes}");
  138|      3|        }
                      ^0
  139|      3|        if let Some(deadline) = &task.deadline {
                                  ^2
  140|      2|            println!("    Deadline: {deadline}");
  141|      2|        }
                      ^1
  142|      3|        if !task.tags.is_empty() {
  143|      0|            println!("    Tags: {}", task.tags.join(", "));
  144|      3|        }
  145|      3|        println!();
  146|       |    }
  147|      3|}
  148|       |
  149|      2|fn print_projects(projects: &[things_core::Project]) {
  150|      2|    if projects.is_empty() {
  151|      1|        println!("No projects found");
  152|      1|        return;
  153|      1|    }
  154|       |
  155|      1|    println!("Found {} projects:", projects.len());
  156|      2|    for project in projects {
                      ^1
  157|      1|        println!("  â€¢ {} ({:?})", project.title, project.status);
  158|      1|        if let Some(notes) = &project.notes {
  159|      1|            println!("    Notes: {notes}");
  160|      1|        }
                      ^0
  161|      1|        if let Some(deadline) = &project.deadline {
  162|      1|            println!("    Deadline: {deadline}");
  163|      1|        }
                      ^0
  164|      1|        if !project.tags.is_empty() {
  165|      0|            println!("    Tags: {}", project.tags.join(", "));
  166|      1|        }
  167|      1|        println!();
  168|       |    }
  169|      2|}
  170|       |
  171|      2|fn print_areas(areas: &[things_core::Area]) {
  172|      2|    if areas.is_empty() {
  173|      1|        println!("No areas found");
  174|      1|        return;
  175|      1|    }
  176|       |
  177|      1|    println!("Found {} areas:", areas.len());
  178|      3|    for area in areas {
                      ^2
  179|      2|        println!("  â€¢ {}", area.title);
  180|      2|        if let Some(notes) = &area.notes {
  181|      2|            println!("    Notes: {notes}");
  182|      2|        }
                      ^0
  183|      2|        if !area.tags.is_empty() {
  184|      0|            println!("    Tags: {}", area.tags.join(", "));
  185|      2|        }
  186|      2|        println!();
  187|       |    }
  188|      2|}
  189|       |
  190|      1|fn health_check(db: &ThingsDatabase) -> Result<()> {
  191|      1|    println!("ðŸ” Checking Things 3 database connection...");
  192|       |
  193|       |    // Try to get a small sample of tasks to verify connection
  194|      1|    let tasks = db.get_inbox(Some(1))?;
                                                   ^0
  195|       |
  196|      1|    println!("âœ… Database connection successful");
  197|      1|    println!("ðŸ“Š Found {} tasks in inbox", tasks.len());
  198|      1|    println!("ðŸŽ¯ Things CLI is ready to use!");
  199|       |
  200|      1|    Ok(())
  201|      1|}
  202|       |
  203|      0|async fn start_mcp_server(_mcp_server: mcp::ThingsMcpServer) -> Result<()> {
  204|      0|    println!("ðŸ”„ MCP server is running...");
  205|      0|    println!("ðŸ’¡ Use Ctrl+C to stop the server");
  206|      0|    println!();
  207|       |
  208|       |    // For now, just keep the server running
  209|       |    // In a real implementation, this would handle MCP protocol communication
  210|       |    loop {
  211|      0|        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
  212|       |    }
  213|       |}
  214|       |
  215|       |#[cfg(test)]
  216|       |mod tests {
  217|       |    use super::*;
  218|       |    use tempfile::tempdir;
  219|       |    use things_core::test_utils::create_mock_tasks;
  220|       |
  221|       |    #[test]
  222|      1|    fn test_cli_parsing_inbox() {
  223|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox", "--limit", "10"]).unwrap();
  224|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: Some(10) }));
                              ^0
  225|      1|        assert!(!cli.verbose);
  226|      1|        assert!(!cli.fallback_to_default);
  227|      1|    }
  228|       |
  229|       |    #[test]
  230|      1|    fn test_cli_parsing_today() {
  231|      1|        let cli = Cli::try_parse_from(["things-cli", "today", "--limit", "5"]).unwrap();
  232|      1|        assert!(matches!(cli.command, Commands::Today { limit: Some(5) }));
                              ^0
  233|      1|    }
  234|       |
  235|       |    #[test]
  236|      1|    fn test_cli_parsing_projects() {
  237|      1|        let cli = Cli::try_parse_from(["things-cli", "projects", "--area", "test-uuid"]).unwrap();
  238|      1|        assert!(
  239|      1|            matches!(cli.command, Commands::Projects { area: Some(ref area) } if area == "test-uuid")
  240|       |        );
  241|      1|    }
  242|       |
  243|       |    #[test]
  244|      1|    fn test_cli_parsing_areas() {
  245|      1|        let cli = Cli::try_parse_from(["things-cli", "areas"]).unwrap();
  246|      1|        assert!(matches!(cli.command, Commands::Areas));
                              ^0
  247|      1|    }
  248|       |
  249|       |    #[test]
  250|      1|    fn test_cli_parsing_search() {
  251|      1|        let cli =
  252|      1|            Cli::try_parse_from(["things-cli", "search", "test query", "--limit", "20"]).unwrap();
  253|      1|        assert!(
  254|      1|            matches!(cli.command, Commands::Search { query: ref q, limit: Some(20) } if q == "test query")
  255|       |        );
  256|      1|    }
  257|       |
  258|       |    #[test]
  259|      1|    fn test_cli_parsing_mcp() {
  260|      1|        let cli = Cli::try_parse_from(["things-cli", "mcp"]).unwrap();
  261|      1|        assert!(matches!(cli.command, Commands::Mcp));
                              ^0
  262|      1|    }
  263|       |
  264|       |    #[test]
  265|      1|    fn test_cli_parsing_health() {
  266|      1|        let cli = Cli::try_parse_from(["things-cli", "health"]).unwrap();
  267|      1|        assert!(matches!(cli.command, Commands::Health));
                              ^0
  268|      1|    }
  269|       |
  270|       |    #[test]
  271|      1|    fn test_cli_parsing_with_database_path() {
  272|      1|        let cli =
  273|      1|            Cli::try_parse_from(["things-cli", "--database", "/path/to/db", "inbox"]).unwrap();
  274|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: None }));
                              ^0
  275|      1|        assert!(cli.database.is_some());
  276|      1|        assert_eq!(cli.database.unwrap(), PathBuf::from("/path/to/db"));
  277|      1|    }
  278|       |
  279|       |    #[test]
  280|      1|    fn test_cli_parsing_with_verbose() {
  281|      1|        let cli = Cli::try_parse_from(["things-cli", "--verbose", "inbox"]).unwrap();
  282|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: None }));
                              ^0
  283|      1|        assert!(cli.verbose);
  284|      1|    }
  285|       |
  286|       |    #[test]
  287|      1|    fn test_cli_parsing_with_fallback() {
  288|      1|        let cli = Cli::try_parse_from(["things-cli", "--fallback-to-default", "inbox"]).unwrap();
  289|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: None }));
                              ^0
  290|      1|        assert!(cli.fallback_to_default);
  291|      1|    }
  292|       |
  293|       |    #[test]
  294|      1|    fn test_cli_parsing_all_options() {
  295|      1|        let cli = Cli::try_parse_from([
  296|      1|            "things-cli",
  297|      1|            "--database",
  298|      1|            "/custom/db",
  299|      1|            "--fallback-to-default",
  300|      1|            "--verbose",
  301|      1|            "search",
  302|      1|            "test",
  303|      1|            "--limit",
  304|      1|            "15",
  305|      1|        ])
  306|      1|        .unwrap();
  307|      1|        assert!(
  308|      1|            matches!(cli.command, Commands::Search { query: ref q, limit: Some(15) } if q == "test")
  309|       |        );
  310|      1|        assert_eq!(cli.database.unwrap(), PathBuf::from("/custom/db"));
  311|      1|        assert!(cli.fallback_to_default);
  312|      1|        assert!(cli.verbose);
  313|      1|    }
  314|       |
  315|       |    #[test]
  316|      1|    fn test_print_tasks_empty() {
  317|      1|        let tasks = vec![];
  318|       |        // This should not panic
  319|      1|        print_tasks(&tasks);
  320|      1|    }
  321|       |
  322|       |    #[test]
  323|      1|    fn test_print_tasks_with_data() {
  324|      1|        let tasks = create_mock_tasks();
  325|       |        // This should not panic
  326|      1|        print_tasks(&tasks);
  327|      1|    }
  328|       |
  329|       |    #[test]
  330|      1|    fn test_print_tasks_single() {
  331|      1|        let tasks = vec![create_mock_tasks()[0].clone()];
  332|       |        // This should not panic
  333|      1|        print_tasks(&tasks);
  334|      1|    }
  335|       |
  336|       |    #[test]
  337|      1|    fn test_print_projects_empty() {
  338|      1|        let projects = vec![];
  339|       |        // This should not panic
  340|      1|        print_projects(&projects);
  341|      1|    }
  342|       |
  343|       |    #[test]
  344|      1|    fn test_print_projects_with_data() {
  345|      1|        let projects = things_core::test_utils::create_mock_projects();
  346|       |        // This should not panic
  347|      1|        print_projects(&projects);
  348|      1|    }
  349|       |
  350|       |    #[test]
  351|      1|    fn test_print_areas_empty() {
  352|      1|        let areas = vec![];
  353|       |        // This should not panic
  354|      1|        print_areas(&areas);
  355|      1|    }
  356|       |
  357|       |    #[test]
  358|      1|    fn test_print_areas_with_data() {
  359|      1|        let areas = things_core::test_utils::create_mock_areas();
  360|       |        // This should not panic
  361|      1|        print_areas(&areas);
  362|      1|    }
  363|       |
  364|       |    #[test]
  365|      1|    fn test_health_check_success() {
  366|      1|        let temp_dir = tempdir().unwrap();
  367|      1|        let db_path = temp_dir.path().join("test.db");
  368|       |
  369|       |        // Create a test database
  370|      1|        things_core::test_utils::create_test_database(&db_path).unwrap();
  371|       |
  372|      1|        let config = ThingsConfig::new(&db_path, false);
  373|      1|        let db = ThingsDatabase::with_config(&config).unwrap();
  374|       |
  375|       |        // This should not panic
  376|      1|        let result = health_check(&db);
  377|      1|        assert!(result.is_ok());
  378|      1|    }
  379|       |
  380|       |    #[test]
  381|      1|    fn test_health_check_database_error() {
  382|      1|        let temp_dir = tempdir().unwrap();
  383|      1|        let db_path = temp_dir.path().join("nonexistent.db");
  384|       |
  385|      1|        let config = ThingsConfig::new(&db_path, false);
  386|      1|        let result = ThingsDatabase::with_config(&config);
  387|       |
  388|       |        // This should fail because the database doesn't exist and fallback is disabled
  389|      1|        assert!(result.is_err());
  390|      1|    }
  391|       |
  392|       |    #[test]
  393|      1|    fn test_commands_enum_debug() {
  394|      1|        let commands = vec![
  395|      1|            Commands::Inbox { limit: None },
  396|      1|            Commands::Today { limit: Some(10) },
  397|      1|            Commands::Projects {
  398|      1|                area: Some("test".to_string()),
  399|      1|            },
  400|      1|            Commands::Areas,
  401|      1|            Commands::Search {
  402|      1|                query: "test".to_string(),
  403|      1|                limit: None,
  404|      1|            },
  405|      1|            Commands::Mcp,
  406|      1|            Commands::Health,
  407|       |        ];
  408|       |
  409|      8|        for command in commands {
                          ^7
  410|      7|            let debug_str = format!("{:?}", command);
  411|      7|            assert!(!debug_str.is_empty());
  412|       |        }
  413|      1|    }
  414|       |
  415|       |    #[test]
  416|      1|    fn test_cli_struct_debug() {
  417|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox"]).unwrap();
  418|      1|        let debug_str = format!("{:?}", cli);
  419|      1|        assert!(!debug_str.is_empty());
  420|      1|    }
  421|       |
  422|       |    #[test]
  423|      1|    fn test_cli_parsing_invalid_command() {
  424|      1|        let result = Cli::try_parse_from(["things-cli", "invalid-command"]);
  425|      1|        assert!(result.is_err());
  426|      1|    }
  427|       |
  428|       |    #[test]
  429|      1|    fn test_cli_parsing_missing_command() {
  430|      1|        let result = Cli::try_parse_from(["things-cli"]);
  431|      1|        assert!(result.is_err());
  432|      1|    }
  433|       |
  434|       |    #[test]
  435|      1|    fn test_cli_parsing_help() {
  436|      1|        let result = Cli::try_parse_from(["things-cli", "--help"]);
  437|      1|        assert!(result.is_err()); // Help causes early exit
  438|      1|    }
  439|       |
  440|       |    #[test]
  441|      1|    fn test_cli_parsing_version() {
  442|      1|        let result = Cli::try_parse_from(["things-cli", "--version"]);
  443|      1|        assert!(result.is_err()); // Version causes early exit
  444|      1|    }
  445|       |
  446|       |    #[test]
  447|      1|    fn test_commands_equality() {
  448|      1|        let cmd1 = Commands::Inbox { limit: None };
  449|      1|        let cmd2 = Commands::Inbox { limit: None };
  450|      1|        let cmd3 = Commands::Inbox { limit: Some(10) };
  451|      1|        let cmd4 = Commands::Today { limit: None };
  452|       |
  453|       |        // Note: These tests will fail if Commands doesn't implement PartialEq
  454|       |        // This is expected for enums with data
  455|      1|        assert!(matches!(cmd1, Commands::Inbox { limit: None }));
                              ^0
  456|      1|        assert!(matches!(cmd2, Commands::Inbox { limit: None }));
                              ^0
  457|      1|        assert!(matches!(cmd3, Commands::Inbox { limit: Some(10) }));
                              ^0
  458|      1|        assert!(matches!(cmd4, Commands::Today { limit: None }));
                              ^0
  459|      1|    }
  460|       |
  461|       |    #[test]
  462|      1|    fn test_cli_default_values() {
  463|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox"]).unwrap();
  464|      1|        assert!(cli.database.is_none());
  465|      1|        assert!(!cli.fallback_to_default);
  466|      1|        assert!(!cli.verbose);
  467|      1|    }
  468|       |
  469|       |    #[test]
  470|      1|    fn test_cli_short_flags() {
  471|      1|        let cli = Cli::try_parse_from(["things-cli", "-v", "-d", "/path", "inbox"]).unwrap();
  472|      1|        assert!(cli.verbose);
  473|      1|        assert!(cli.database.is_some());
  474|      1|        assert_eq!(cli.database.unwrap(), PathBuf::from("/path"));
  475|      1|    }
  476|       |
  477|       |    #[test]
  478|      1|    fn test_cli_short_limit() {
  479|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox", "-l", "5"]).unwrap();
  480|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: Some(5) }));
                              ^0
  481|      1|    }
  482|       |
  483|       |    #[test]
  484|      1|    fn test_cli_search_without_limit() {
  485|      1|        let cli = Cli::try_parse_from(["things-cli", "search", "test query"]).unwrap();
  486|      1|        assert!(
  487|      1|            matches!(cli.command, Commands::Search { query: ref q, limit: None } if q == "test query")
  488|       |        );
  489|      1|    }
  490|       |
  491|       |    #[test]
  492|      1|    fn test_cli_projects_without_area() {
  493|      1|        let cli = Cli::try_parse_from(["things-cli", "projects"]).unwrap();
  494|      1|        assert!(matches!(cli.command, Commands::Projects { area: None }));
                              ^0
  495|      1|    }
  496|       |
  497|       |    #[test]
  498|      1|    fn test_cli_inbox_without_limit() {
  499|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox"]).unwrap();
  500|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: None }));
                              ^0
  501|      1|    }
  502|       |
  503|       |    #[test]
  504|      1|    fn test_cli_parsing_all_options_comprehensive() {
  505|      1|        let cli = Cli::try_parse_from([
  506|      1|            "things-cli",
  507|      1|            "--database",
  508|      1|            "/custom/path",
  509|      1|            "--fallback-to-default",
  510|      1|            "--verbose",
  511|      1|            "inbox",
  512|      1|            "--limit",
  513|      1|            "5",
  514|      1|        ])
  515|      1|        .unwrap();
  516|       |
  517|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: Some(5) }));
                              ^0
  518|      1|        assert!(cli.verbose);
  519|      1|        assert!(cli.fallback_to_default);
  520|      1|        assert_eq!(cli.database.unwrap(), PathBuf::from("/custom/path"));
  521|      1|    }
  522|       |
  523|       |    #[test]
  524|      1|    fn test_main_function_execution_paths() {
  525|       |        // Test that main function can be called with different commands
  526|       |        // This tests the execution flow without actually running the full main function
  527|       |
  528|       |        // Test inbox command parsing
  529|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox", "--limit", "10"]).unwrap();
  530|      1|        assert!(matches!(cli.command, Commands::Inbox { limit: Some(10) }));
                              ^0
  531|       |
  532|       |        // Test today command parsing
  533|      1|        let cli = Cli::try_parse_from(["things-cli", "today"]).unwrap();
  534|      1|        assert!(matches!(cli.command, Commands::Today { limit: None }));
                              ^0
  535|       |
  536|       |        // Test projects command parsing
  537|      1|        let cli = Cli::try_parse_from(["things-cli", "projects", "--area", "test-uuid"]).unwrap();
  538|      1|        assert!(
  539|      1|            matches!(cli.command, Commands::Projects { area: Some(ref area) } if area == "test-uuid")
  540|       |        );
  541|       |
  542|       |        // Test areas command parsing
  543|      1|        let cli = Cli::try_parse_from(["things-cli", "areas"]).unwrap();
  544|      1|        assert!(matches!(cli.command, Commands::Areas));
                              ^0
  545|       |
  546|       |        // Test search command parsing
  547|      1|        let cli =
  548|      1|            Cli::try_parse_from(["things-cli", "search", "test query", "--limit", "5"]).unwrap();
  549|      1|        assert!(
  550|      1|            matches!(cli.command, Commands::Search { query: ref q, limit: Some(5) } if q == "test query")
  551|       |        );
  552|       |
  553|       |        // Test mcp command parsing
  554|      1|        let cli = Cli::try_parse_from(["things-cli", "mcp"]).unwrap();
  555|      1|        assert!(matches!(cli.command, Commands::Mcp));
                              ^0
  556|       |
  557|       |        // Test health command parsing
  558|      1|        let cli = Cli::try_parse_from(["things-cli", "health"]).unwrap();
  559|      1|        assert!(matches!(cli.command, Commands::Health));
                              ^0
  560|      1|    }
  561|       |
  562|       |    #[test]
  563|      1|    fn test_config_creation_paths() {
  564|       |        // Test config creation with database path
  565|      1|        let cli = Cli::try_parse_from(["things-cli", "--database", "/test/path", "inbox"]).unwrap();
  566|      1|        let config = if let Some(db_path) = cli.database {
  567|      1|            ThingsConfig::new(db_path, cli.fallback_to_default)
  568|       |        } else {
  569|      0|            ThingsConfig::from_env()
  570|       |        };
  571|       |
  572|      1|        assert_eq!(config.database_path, PathBuf::from("/test/path"));
  573|      1|        assert!(!config.fallback_to_default);
  574|       |
  575|       |        // Test config creation without database path
  576|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox"]).unwrap();
  577|      1|        let config = if let Some(db_path) = cli.database {
                                               ^0
  578|      0|            ThingsConfig::new(db_path, cli.fallback_to_default)
  579|       |        } else {
  580|      1|            ThingsConfig::from_env()
  581|       |        };
  582|       |
  583|       |        // Should use default path from env (may or may not contain "Things3" depending on system)
  584|      1|        assert!(!config.database_path.to_string_lossy().is_empty());
  585|      1|    }
  586|       |
  587|       |    #[test]
  588|      1|    fn test_verbose_logging_setup() {
  589|       |        // Test that verbose flag is properly parsed
  590|      1|        let cli = Cli::try_parse_from(["things-cli", "--verbose", "inbox"]).unwrap();
  591|      1|        assert!(cli.verbose);
  592|       |
  593|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox"]).unwrap();
  594|      1|        assert!(!cli.verbose);
  595|       |
  596|      1|        let cli = Cli::try_parse_from(["things-cli", "-v", "inbox"]).unwrap();
  597|      1|        assert!(cli.verbose);
  598|      1|    }
  599|       |
  600|       |    #[test]
  601|      1|    fn test_fallback_behavior_parsing() {
  602|      1|        let cli = Cli::try_parse_from(["things-cli", "--fallback-to-default", "inbox"]).unwrap();
  603|      1|        assert!(cli.fallback_to_default);
  604|       |
  605|      1|        let cli = Cli::try_parse_from(["things-cli", "inbox"]).unwrap();
  606|      1|        assert!(!cli.fallback_to_default);
  607|      1|    }
  608|       |
  609|       |    #[test]
  610|      1|    fn test_command_enum_variants() {
  611|       |        // Test all command variants can be created and debugged
  612|      1|        let commands = vec![
  613|      1|            Commands::Inbox { limit: None },
  614|      1|            Commands::Inbox { limit: Some(10) },
  615|      1|            Commands::Today { limit: None },
  616|      1|            Commands::Today { limit: Some(5) },
  617|      1|            Commands::Projects { area: None },
  618|      1|            Commands::Projects {
  619|      1|                area: Some("test".to_string()),
  620|      1|            },
  621|      1|            Commands::Areas,
  622|      1|            Commands::Search {
  623|      1|                query: "test".to_string(),
  624|      1|                limit: None,
  625|      1|            },
  626|      1|            Commands::Search {
  627|      1|                query: "test".to_string(),
  628|      1|                limit: Some(10),
  629|      1|            },
  630|      1|            Commands::Mcp,
  631|      1|            Commands::Health,
  632|       |        ];
  633|       |
  634|     12|        for command in commands {
                          ^11
  635|     11|            let debug_str = format!("{:?}", command);
  636|     11|            assert!(!debug_str.is_empty());
  637|     11|            assert!(
  638|     11|                debug_str.contains("Inbox")
  639|      9|                    || debug_str.contains("Today")
  640|      7|                    || debug_str.contains("Projects")
  641|      5|                    || debug_str.contains("Areas")
  642|      4|                    || debug_str.contains("Search")
  643|      2|                    || debug_str.contains("Mcp")
  644|      1|                    || debug_str.contains("Health")
  645|       |            );
  646|       |        }
  647|      1|    }
  648|       |
  649|       |    #[test]
  650|      1|    fn test_cli_today_without_limit() {
  651|      1|        let cli = Cli::try_parse_from(["things-cli", "today"]).unwrap();
  652|      1|        assert!(matches!(cli.command, Commands::Today { limit: None }));
                              ^0
  653|      1|    }
  654|       |}

/Users/garthdb/Projects/rust-things/apps/things-cli/src/mcp.rs:
    1|       |//! MCP (Model Context Protocol) server implementation for Things 3 integration
    2|       |
    3|       |use anyhow::Result;
    4|       |use serde::{Deserialize, Serialize};
    5|       |use serde_json::Value;
    6|       |use things_core::{
    7|       |    BackupManager, DataExporter, PerformanceMonitor, ThingsCache, ThingsConfig, ThingsDatabase,
    8|       |};
    9|       |
   10|       |/// Simplified MCP types for our implementation
   11|       |#[derive(Debug, Serialize, Deserialize)]
   12|       |pub struct Tool {
   13|       |    pub name: String,
   14|       |    pub description: String,
   15|       |    pub input_schema: Value,
   16|       |}
   17|       |
   18|       |#[derive(Debug, Serialize, Deserialize)]
   19|       |pub struct CallToolRequest {
   20|       |    pub name: String,
   21|       |    pub arguments: Option<Value>,
   22|       |}
   23|       |
   24|       |#[derive(Debug, Serialize, Deserialize)]
   25|       |pub struct CallToolResult {
   26|       |    pub content: Vec<Content>,
   27|       |    pub is_error: bool,
   28|       |}
   29|       |
   30|       |#[derive(Debug, Serialize, Deserialize)]
   31|       |pub enum Content {
   32|       |    Text { text: String },
   33|       |}
   34|       |
   35|       |#[derive(Debug, Serialize, Deserialize)]
   36|       |pub struct ListToolsResult {
   37|       |    pub tools: Vec<Tool>,
   38|       |}
   39|       |
   40|       |/// MCP server for Things 3 integration
   41|       |pub struct ThingsMcpServer {
   42|       |    #[allow(dead_code)]
   43|       |    db: ThingsDatabase,
   44|       |    #[allow(dead_code)]
   45|       |    cache: ThingsCache,
   46|       |    #[allow(dead_code)]
   47|       |    performance_monitor: PerformanceMonitor,
   48|       |    #[allow(dead_code)]
   49|       |    exporter: DataExporter,
   50|       |    #[allow(dead_code)]
   51|       |    backup_manager: BackupManager,
   52|       |}
   53|       |
   54|       |#[allow(dead_code)]
   55|       |impl ThingsMcpServer {
   56|     38|    pub fn new(db: ThingsDatabase, config: ThingsConfig) -> Self {
   57|     38|        let cache = ThingsCache::new_default();
   58|     38|        let performance_monitor = PerformanceMonitor::new_default();
   59|     38|        let exporter = DataExporter::new_default();
   60|     38|        let backup_manager = BackupManager::new(config);
   61|       |
   62|     38|        Self {
   63|     38|            db,
   64|     38|            cache,
   65|     38|            performance_monitor,
   66|     38|            exporter,
   67|     38|            backup_manager,
   68|     38|        }
   69|     38|    }
   70|       |
   71|       |    /// List available MCP tools
   72|      3|    pub async fn list_tools(&self) -> Result<ListToolsResult> {
   73|       |        Ok(ListToolsResult {
   74|      3|            tools: self.get_available_tools().await?,
                                                                 ^0
   75|       |        })
   76|      3|    }
   77|       |
   78|       |    /// Call a specific MCP tool
   79|     34|    pub async fn call_tool(&self, request: CallToolRequest) -> Result<CallToolResult> {
   80|     34|        self.handle_tool_call(request).await
   81|     34|    }
   82|       |
   83|       |    /// Get available MCP tools
   84|      3|    async fn get_available_tools(&self) -> Result<Vec<Tool>> {
   85|      3|        Ok(vec![
   86|      3|            Tool {
   87|      3|                name: "get_inbox".to_string(),
   88|      3|                description: "Get tasks from the inbox".to_string(),
   89|      3|                input_schema: serde_json::json!({
   90|      3|                    "type": "object",
   91|      3|                    "properties": {
   92|      3|                        "limit": {
   93|      3|                            "type": "integer",
   94|      3|                            "description": "Maximum number of tasks to return"
   95|      3|                        }
   96|      3|                    }
   97|      3|                }),
   98|      3|            },
   99|      3|            Tool {
  100|      3|                name: "get_today".to_string(),
  101|      3|                description: "Get tasks scheduled for today".to_string(),
  102|      3|                input_schema: serde_json::json!({
  103|      3|                    "type": "object",
  104|      3|                    "properties": {
  105|      3|                        "limit": {
  106|      3|                            "type": "integer",
  107|      3|                            "description": "Maximum number of tasks to return"
  108|      3|                        }
  109|      3|                    }
  110|      3|                }),
  111|      3|            },
  112|      3|            Tool {
  113|      3|                name: "get_projects".to_string(),
  114|      3|                description: "Get all projects, optionally filtered by area".to_string(),
  115|      3|                input_schema: serde_json::json!({
  116|      3|                    "type": "object",
  117|      3|                    "properties": {
  118|      3|                        "area_uuid": {
  119|      3|                            "type": "string",
  120|      3|                            "description": "Optional area UUID to filter projects"
  121|      3|                        }
  122|      3|                    }
  123|      3|                }),
  124|      3|            },
  125|      3|            Tool {
  126|      3|                name: "get_areas".to_string(),
  127|      3|                description: "Get all areas".to_string(),
  128|      3|                input_schema: serde_json::json!({
  129|      3|                    "type": "object",
  130|      3|                    "properties": {}
  131|      3|                }),
  132|      3|            },
  133|      3|            Tool {
  134|      3|                name: "search_tasks".to_string(),
  135|      3|                description: "Search for tasks by query".to_string(),
  136|      3|                input_schema: serde_json::json!({
  137|      3|                    "type": "object",
  138|      3|                    "properties": {
  139|      3|                        "query": {
  140|      3|                            "type": "string",
  141|      3|                            "description": "Search query"
  142|      3|                        },
  143|      3|                        "limit": {
  144|      3|                            "type": "integer",
  145|      3|                            "description": "Maximum number of tasks to return"
  146|      3|                        }
  147|      3|                    },
  148|      3|                    "required": ["query"]
  149|      3|                }),
  150|      3|            },
  151|      3|            Tool {
  152|      3|                name: "create_task".to_string(),
  153|      3|                description: "Create a new task".to_string(),
  154|      3|                input_schema: serde_json::json!({
  155|      3|                    "type": "object",
  156|      3|                    "properties": {
  157|      3|                        "title": {
  158|      3|                            "type": "string",
  159|      3|                            "description": "Task title"
  160|      3|                        },
  161|      3|                        "notes": {
  162|      3|                            "type": "string",
  163|      3|                            "description": "Optional task notes"
  164|      3|                        },
  165|      3|                        "project_uuid": {
  166|      3|                            "type": "string",
  167|      3|                            "description": "Optional project UUID"
  168|      3|                        },
  169|      3|                        "area_uuid": {
  170|      3|                            "type": "string",
  171|      3|                            "description": "Optional area UUID"
  172|      3|                        }
  173|      3|                    },
  174|      3|                    "required": ["title"]
  175|      3|                }),
  176|      3|            },
  177|      3|            Tool {
  178|      3|                name: "update_task".to_string(),
  179|      3|                description: "Update an existing task".to_string(),
  180|      3|                input_schema: serde_json::json!({
  181|      3|                    "type": "object",
  182|      3|                    "properties": {
  183|      3|                        "uuid": {
  184|      3|                            "type": "string",
  185|      3|                            "description": "Task UUID"
  186|      3|                        },
  187|      3|                        "title": {
  188|      3|                            "type": "string",
  189|      3|                            "description": "New task title"
  190|      3|                        },
  191|      3|                        "notes": {
  192|      3|                            "type": "string",
  193|      3|                            "description": "New task notes"
  194|      3|                        },
  195|      3|                        "status": {
  196|      3|                            "type": "string",
  197|      3|                            "description": "New task status",
  198|      3|                            "enum": ["incomplete", "completed", "canceled", "trashed"]
  199|      3|                        }
  200|      3|                    },
  201|      3|                    "required": ["uuid"]
  202|      3|                }),
  203|      3|            },
  204|      3|            Tool {
  205|      3|                name: "get_productivity_metrics".to_string(),
  206|      3|                description: "Get productivity metrics and statistics".to_string(),
  207|      3|                input_schema: serde_json::json!({
  208|      3|                    "type": "object",
  209|      3|                    "properties": {
  210|      3|                        "days": {
  211|      3|                            "type": "integer",
  212|      3|                            "description": "Number of days to look back for metrics"
  213|      3|                        }
  214|      3|                    }
  215|      3|                }),
  216|      3|            },
  217|      3|            Tool {
  218|      3|                name: "export_data".to_string(),
  219|      3|                description: "Export data in various formats".to_string(),
  220|      3|                input_schema: serde_json::json!({
  221|      3|                    "type": "object",
  222|      3|                    "properties": {
  223|      3|                        "format": {
  224|      3|                            "type": "string",
  225|      3|                            "description": "Export format",
  226|      3|                            "enum": ["json", "csv", "markdown"]
  227|      3|                        },
  228|      3|                        "data_type": {
  229|      3|                            "type": "string",
  230|      3|                            "description": "Type of data to export",
  231|      3|                            "enum": ["tasks", "projects", "areas", "all"]
  232|      3|                        }
  233|      3|                    },
  234|      3|                    "required": ["format", "data_type"]
  235|      3|                }),
  236|      3|            },
  237|      3|            Tool {
  238|      3|                name: "bulk_create_tasks".to_string(),
  239|      3|                description: "Create multiple tasks at once".to_string(),
  240|      3|                input_schema: serde_json::json!({
  241|      3|                    "type": "object",
  242|      3|                    "properties": {
  243|      3|                        "tasks": {
  244|      3|                            "type": "array",
  245|      3|                            "description": "Array of task objects to create",
  246|      3|                            "items": {
  247|      3|                                "type": "object",
  248|      3|                                "properties": {
  249|      3|                                    "title": {"type": "string"},
  250|      3|                                    "notes": {"type": "string"},
  251|      3|                                    "project_uuid": {"type": "string"},
  252|      3|                                    "area_uuid": {"type": "string"}
  253|      3|                                },
  254|      3|                                "required": ["title"]
  255|      3|                            }
  256|      3|                        }
  257|      3|                    },
  258|      3|                    "required": ["tasks"]
  259|      3|                }),
  260|      3|            },
  261|      3|            Tool {
  262|      3|                name: "get_recent_tasks".to_string(),
  263|      3|                description: "Get recently created or modified tasks".to_string(),
  264|      3|                input_schema: serde_json::json!({
  265|      3|                    "type": "object",
  266|      3|                    "properties": {
  267|      3|                        "limit": {
  268|      3|                            "type": "integer",
  269|      3|                            "description": "Maximum number of tasks to return"
  270|      3|                        },
  271|      3|                        "hours": {
  272|      3|                            "type": "integer",
  273|      3|                            "description": "Number of hours to look back"
  274|      3|                        }
  275|      3|                    }
  276|      3|                }),
  277|      3|            },
  278|      3|            Tool {
  279|      3|                name: "backup_database".to_string(),
  280|      3|                description: "Create a backup of the Things 3 database".to_string(),
  281|      3|                input_schema: serde_json::json!({
  282|      3|                    "type": "object",
  283|      3|                    "properties": {
  284|      3|                        "backup_dir": {
  285|      3|                            "type": "string",
  286|      3|                            "description": "Directory to store the backup"
  287|      3|                        },
  288|      3|                        "description": {
  289|      3|                            "type": "string",
  290|      3|                            "description": "Optional description for the backup"
  291|      3|                        }
  292|      3|                    },
  293|      3|                    "required": ["backup_dir"]
  294|      3|                }),
  295|      3|            },
  296|      3|            Tool {
  297|      3|                name: "restore_database".to_string(),
  298|      3|                description: "Restore from a backup".to_string(),
  299|      3|                input_schema: serde_json::json!({
  300|      3|                    "type": "object",
  301|      3|                    "properties": {
  302|      3|                        "backup_path": {
  303|      3|                            "type": "string",
  304|      3|                            "description": "Path to the backup file"
  305|      3|                        }
  306|      3|                    },
  307|      3|                    "required": ["backup_path"]
  308|      3|                }),
  309|      3|            },
  310|      3|            Tool {
  311|      3|                name: "list_backups".to_string(),
  312|      3|                description: "List available backups".to_string(),
  313|      3|                input_schema: serde_json::json!({
  314|      3|                    "type": "object",
  315|      3|                    "properties": {
  316|      3|                        "backup_dir": {
  317|      3|                            "type": "string",
  318|      3|                            "description": "Directory containing backups"
  319|      3|                        }
  320|      3|                    },
  321|      3|                    "required": ["backup_dir"]
  322|      3|                }),
  323|      3|            },
  324|      3|            Tool {
  325|      3|                name: "get_performance_stats".to_string(),
  326|      3|                description: "Get performance statistics and metrics".to_string(),
  327|      3|                input_schema: serde_json::json!({
  328|      3|                    "type": "object",
  329|      3|                    "properties": {}
  330|      3|                }),
  331|      3|            },
  332|      3|            Tool {
  333|      3|                name: "get_system_metrics".to_string(),
  334|      3|                description: "Get current system resource metrics".to_string(),
  335|      3|                input_schema: serde_json::json!({
  336|      3|                    "type": "object",
  337|      3|                    "properties": {}
  338|      3|                }),
  339|      3|            },
  340|      3|            Tool {
  341|      3|                name: "get_cache_stats".to_string(),
  342|      3|                description: "Get cache statistics and hit rates".to_string(),
  343|      3|                input_schema: serde_json::json!({
  344|      3|                    "type": "object",
  345|      3|                    "properties": {}
  346|      3|                }),
  347|      3|            },
  348|      3|        ])
  349|      3|    }
  350|       |
  351|       |    /// Handle tool call
  352|     34|    async fn handle_tool_call(&self, request: CallToolRequest) -> Result<CallToolResult> {
  353|     34|        let tool_name = &request.name;
  354|     34|        let arguments = request.arguments.unwrap_or_default();
  355|       |
  356|     34|        let result = match tool_name.as_str() {
                          ^33
  357|     34|            "get_inbox" => self.handle_get_inbox(arguments).await,
                                         ^4   ^4
  358|     30|            "get_today" => self.handle_get_today(arguments).await,
                                         ^1   ^1
  359|     29|            "get_projects" => self.handle_get_projects(arguments).await,
                                            ^2   ^2
  360|     27|            "get_areas" => self.handle_get_areas(arguments).await,
                                         ^1   ^1
  361|     26|            "search_tasks" => self.handle_search_tasks(arguments).await,
                                            ^2   ^2
  362|     24|            "create_task" => self.handle_create_task(arguments).await,
                                           ^2   ^2
  363|     22|            "update_task" => self.handle_update_task(arguments).await,
                                           ^2   ^2
  364|     20|            "get_productivity_metrics" => self.handle_get_productivity_metrics(arguments).await,
                                                        ^2   ^2
  365|     18|            "export_data" => self.handle_export_data(arguments).await,
                                           ^4   ^4
  366|     14|            "bulk_create_tasks" => self.handle_bulk_create_tasks(arguments).await,
                                                 ^2   ^2
  367|     12|            "get_recent_tasks" => self.handle_get_recent_tasks(arguments).await,
                                                ^2   ^2
  368|     10|            "backup_database" => self.handle_backup_database(arguments).await,
                                               ^2   ^2
  369|      8|            "restore_database" => self.handle_restore_database(arguments).await,
                                                ^2   ^2
  370|      6|            "list_backups" => self.handle_list_backups(arguments).await,
                                            ^2   ^2
  371|      4|            "get_performance_stats" => self.handle_get_performance_stats(arguments).await,
                                                     ^1   ^1
  372|      3|            "get_system_metrics" => self.handle_get_system_metrics(arguments).await,
                                                  ^1   ^1
  373|      2|            "get_cache_stats" => self.handle_get_cache_stats(arguments).await,
                                               ^1   ^1
  374|       |            _ => {
  375|      1|                return Ok(CallToolResult {
  376|      1|                    content: vec![Content::Text {
  377|      1|                        text: format!("Unknown tool: {}", tool_name),
  378|      1|                    }],
  379|      1|                    is_error: true,
  380|      1|                });
  381|       |            }
  382|       |        };
  383|       |
  384|     33|        match result {
  385|     22|            Ok(call_result) => Ok(call_result),
  386|     11|            Err(e) => Ok(CallToolResult {
  387|     11|                content: vec![Content::Text {
  388|     11|                    text: format!("Error: {}", e),
  389|     11|                }],
  390|     11|                is_error: true,
  391|     11|            }),
  392|       |        }
  393|     34|    }
  394|       |
  395|      4|    async fn handle_get_inbox(&self, args: Value) -> Result<CallToolResult> {
  396|      4|        let limit = args
  397|      4|            .get("limit")
  398|      4|            .and_then(|v| v.as_u64())
                                        ^2^2
  399|      4|            .map(|v| v as usize);
                                   ^1
  400|      4|        let tasks = self.db.get_inbox(limit)?;
                                                          ^0
  401|      4|        let json = serde_json::to_string_pretty(&tasks)?;
                                                                     ^0
  402|      4|        Ok(CallToolResult {
  403|      4|            content: vec![Content::Text { text: json }],
  404|      4|            is_error: false,
  405|      4|        })
  406|      4|    }
  407|       |
  408|      1|    async fn handle_get_today(&self, args: Value) -> Result<CallToolResult> {
  409|      1|        let limit = args
  410|      1|            .get("limit")
  411|      1|            .and_then(|v| v.as_u64())
  412|      1|            .map(|v| v as usize);
  413|      1|        let tasks = self.db.get_today(limit)?;
                                                          ^0
  414|      1|        let json = serde_json::to_string_pretty(&tasks)?;
                                                                     ^0
  415|      1|        Ok(CallToolResult {
  416|      1|            content: vec![Content::Text { text: json }],
  417|      1|            is_error: false,
  418|      1|        })
  419|      1|    }
  420|       |
  421|      2|    async fn handle_get_projects(&self, args: Value) -> Result<CallToolResult> {
  422|      2|        let area_uuid = args
  423|      2|            .get("area_uuid")
  424|      2|            .and_then(|v| v.as_str())
                                        ^1^1
  425|      2|            .and_then(|s| uuid::Uuid::parse_str(s).ok());
                                        ^1                    ^1 ^1
  426|      2|        let projects = self.db.get_projects(area_uuid)?;
                                                                    ^0
  427|      2|        let json = serde_json::to_string_pretty(&projects)?;
                                                                        ^0
  428|      2|        Ok(CallToolResult {
  429|      2|            content: vec![Content::Text { text: json }],
  430|      2|            is_error: false,
  431|      2|        })
  432|      2|    }
  433|       |
  434|      1|    async fn handle_get_areas(&self, _args: Value) -> Result<CallToolResult> {
  435|      1|        let areas = self.db.get_areas()?;
                                                     ^0
  436|      1|        let json = serde_json::to_string_pretty(&areas)?;
                                                                     ^0
  437|      1|        Ok(CallToolResult {
  438|      1|            content: vec![Content::Text { text: json }],
  439|      1|            is_error: false,
  440|      1|        })
  441|      1|    }
  442|       |
  443|      2|    async fn handle_search_tasks(&self, args: Value) -> Result<CallToolResult> {
  444|      2|        let query = args
                          ^1
  445|      2|            .get("query")
  446|      2|            .and_then(|v| v.as_str())
                                        ^1^1
  447|      2|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: query"))?;
                                                         ^1                                   ^1
  448|      1|        let limit = args
  449|      1|            .get("limit")
  450|      1|            .and_then(|v| v.as_u64())
  451|      1|            .map(|v| v as usize);
  452|      1|        let tasks = self.db.search_tasks(query, limit)?;
                                                                    ^0
  453|      1|        let json = serde_json::to_string_pretty(&tasks)?;
                                                                     ^0
  454|      1|        Ok(CallToolResult {
  455|      1|            content: vec![Content::Text { text: json }],
  456|      1|            is_error: false,
  457|      1|        })
  458|      2|    }
  459|       |
  460|      2|    async fn handle_create_task(&self, args: Value) -> Result<CallToolResult> {
  461|       |        // Note: This is a placeholder - actual task creation would need to be implemented
  462|       |        // in the things-core library
  463|      2|        let title = args
                          ^1
  464|      2|            .get("title")
  465|      2|            .and_then(|v| v.as_str())
                                        ^1^1
  466|      2|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: title"))?;
                                                         ^1                                   ^1
  467|       |
  468|      1|        let response = serde_json::json!({
  469|      1|            "message": "Task creation not yet implemented",
  470|      1|            "title": title,
  471|      1|            "status": "placeholder"
  472|       |        });
  473|       |
  474|       |        Ok(CallToolResult {
  475|      1|            content: vec![Content::Text {
  476|      1|                text: serde_json::to_string_pretty(&response)?,
                                                                           ^0
  477|       |            }],
  478|       |            is_error: false,
  479|       |        })
  480|      2|    }
  481|       |
  482|      2|    async fn handle_update_task(&self, args: Value) -> Result<CallToolResult> {
  483|       |        // Note: This is a placeholder - actual task updating would need to be implemented
  484|       |        // in the things-core library
  485|      2|        let uuid = args
                          ^1
  486|      2|            .get("uuid")
  487|      2|            .and_then(|v| v.as_str())
                                        ^1^1
  488|      2|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: uuid"))?;
                                                         ^1                                  ^1
  489|       |
  490|      1|        let response = serde_json::json!({
  491|      1|            "message": "Task updating not yet implemented",
  492|      1|            "uuid": uuid,
  493|      1|            "status": "placeholder"
  494|       |        });
  495|       |
  496|       |        Ok(CallToolResult {
  497|      1|            content: vec![Content::Text {
  498|      1|                text: serde_json::to_string_pretty(&response)?,
                                                                           ^0
  499|       |            }],
  500|       |            is_error: false,
  501|       |        })
  502|      2|    }
  503|       |
  504|      2|    async fn handle_get_productivity_metrics(&self, args: Value) -> Result<CallToolResult> {
  505|      2|        let days = args.get("days").and_then(|v| v.as_u64()).unwrap_or(7) as usize;
                                                               ^1^1
  506|       |
  507|       |        // Get various metrics
  508|      2|        let inbox_tasks = self.db.get_inbox(None)?;
                                                               ^0
  509|      2|        let today_tasks = self.db.get_today(None)?;
                                                               ^0
  510|      2|        let projects = self.db.get_projects(None)?;
                                                               ^0
  511|      2|        let areas = self.db.get_areas()?;
                                                     ^0
  512|       |
  513|      2|        let metrics = serde_json::json!({
  514|      2|            "period_days": days,
  515|      2|            "inbox_tasks_count": inbox_tasks.len(),
  516|      2|            "today_tasks_count": today_tasks.len(),
  517|      2|            "projects_count": projects.len(),
  518|      2|            "areas_count": areas.len(),
  519|      2|            "completed_tasks": projects.iter().filter(|p| p.status == things_core::TaskStatus::Completed).count(),
                                                                        ^0          ^0
  520|      2|            "incomplete_tasks": projects.iter().filter(|p| p.status == things_core::TaskStatus::Incomplete).count(),
                                                                         ^0          ^0
  521|      2|            "timestamp": chrono::Utc::now()
  522|       |        });
  523|       |
  524|       |        Ok(CallToolResult {
  525|      2|            content: vec![Content::Text {
  526|      2|                text: serde_json::to_string_pretty(&metrics)?,
                                                                          ^0
  527|       |            }],
  528|       |            is_error: false,
  529|       |        })
  530|      2|    }
  531|       |
  532|      4|    async fn handle_export_data(&self, args: Value) -> Result<CallToolResult> {
  533|      4|        let format = args
  534|      4|            .get("format")
  535|      4|            .and_then(|v| v.as_str())
  536|      4|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: format"))?;
                                                         ^0                                    ^0
  537|      4|        let data_type = args
                          ^3
  538|      4|            .get("data_type")
  539|      4|            .and_then(|v| v.as_str())
                                        ^3^3
  540|      4|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: data_type"))?;
                                                         ^1                                       ^1
  541|       |
  542|      3|        let export_data = match data_type {
  543|      3|            "tasks" => {
  544|      2|                let inbox = self.db.get_inbox(None)?;
                                                                 ^0
  545|      2|                let today = self.db.get_today(None)?;
                                                                 ^0
  546|      2|                serde_json::json!({
  547|      2|                    "inbox": inbox,
  548|      2|                    "today": today
  549|       |                })
  550|       |            }
  551|      1|            "projects" => {
  552|      0|                let projects = self.db.get_projects(None)?;
  553|      0|                serde_json::json!({ "projects": projects })
  554|       |            }
  555|      1|            "areas" => {
  556|      0|                let areas = self.db.get_areas()?;
  557|      0|                serde_json::json!({ "areas": areas })
  558|       |            }
  559|      1|            "all" => {
  560|      1|                let inbox = self.db.get_inbox(None)?;
                                                                 ^0
  561|      1|                let today = self.db.get_today(None)?;
                                                                 ^0
  562|      1|                let projects = self.db.get_projects(None)?;
                                                                       ^0
  563|      1|                let areas = self.db.get_areas()?;
                                                             ^0
  564|      1|                serde_json::json!({
  565|      1|                    "inbox": inbox,
  566|      1|                    "today": today,
  567|      1|                    "projects": projects,
  568|      1|                    "areas": areas
  569|       |                })
  570|       |            }
  571|      0|            _ => return Err(anyhow::anyhow!("Invalid data_type: {}", data_type)),
  572|       |        };
  573|       |
  574|      3|        let result = match format {
                          ^2
  575|      3|            "json" => serde_json::to_string_pretty(&export_data)?,
                                    ^2                           ^2           ^0
  576|      1|            "csv" => "CSV export not yet implemented".to_string(),
                                   ^0                               ^0
  577|      1|            "markdown" => "Markdown export not yet implemented".to_string(),
                                        ^0                                    ^0
  578|      1|            _ => return Err(anyhow::anyhow!("Invalid format: {}", format)),
  579|       |        };
  580|       |
  581|      2|        Ok(CallToolResult {
  582|      2|            content: vec![Content::Text { text: result }],
  583|      2|            is_error: false,
  584|      2|        })
  585|      4|    }
  586|       |
  587|      2|    async fn handle_bulk_create_tasks(&self, args: Value) -> Result<CallToolResult> {
  588|      2|        let tasks = args
                          ^1
  589|      2|            .get("tasks")
  590|      2|            .and_then(|v| v.as_array())
                                        ^1^1
  591|      2|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: tasks"))?;
                                                         ^1                                   ^1
  592|       |
  593|      1|        let response = serde_json::json!({
  594|      1|            "message": "Bulk task creation not yet implemented",
  595|      1|            "tasks_count": tasks.len(),
  596|      1|            "status": "placeholder"
  597|       |        });
  598|       |
  599|       |        Ok(CallToolResult {
  600|      1|            content: vec![Content::Text {
  601|      1|                text: serde_json::to_string_pretty(&response)?,
                                                                           ^0
  602|       |            }],
  603|       |            is_error: false,
  604|       |        })
  605|      2|    }
  606|       |
  607|      2|    async fn handle_get_recent_tasks(&self, args: Value) -> Result<CallToolResult> {
  608|      2|        let limit = args
  609|      2|            .get("limit")
  610|      2|            .and_then(|v| v.as_u64())
                                        ^1^1
  611|      2|            .map(|v| v as usize);
                                   ^1
  612|      2|        let hours = args.get("hours").and_then(|v| v.as_u64()).unwrap_or(24) as i64;
                                                                 ^1^1
  613|       |
  614|       |        // For now, return inbox tasks as a proxy for recent tasks
  615|       |        // In a real implementation, this would query by creation/modification date
  616|      2|        let tasks = self.db.get_inbox(limit)?;
                                                          ^0
  617|       |
  618|      2|        let response = serde_json::json!({
  619|      2|            "message": "Recent tasks (using inbox as proxy)",
  620|      2|            "hours_lookback": hours,
  621|      2|            "tasks": tasks
  622|       |        });
  623|       |
  624|       |        Ok(CallToolResult {
  625|      2|            content: vec![Content::Text {
  626|      2|                text: serde_json::to_string_pretty(&response)?,
                                                                           ^0
  627|       |            }],
  628|       |            is_error: false,
  629|       |        })
  630|      2|    }
  631|       |
  632|      2|    async fn handle_backup_database(&self, args: Value) -> Result<CallToolResult> {
  633|      2|        let backup_dir = args
                          ^1
  634|      2|            .get("backup_dir")
  635|      2|            .and_then(|v| v.as_str())
                                        ^1^1
  636|      2|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: backup_dir"))?;
                                                         ^1                                        ^1
  637|      1|        let description = args.get("description").and_then(|v| v.as_str());
  638|       |
  639|      1|        let backup_path = std::path::Path::new(backup_dir);
  640|      1|        let metadata = self
                          ^0
  641|      1|            .backup_manager
  642|      1|            .create_backup(backup_path, description)
  643|      1|            .await?;
  644|       |
  645|      0|        let response = serde_json::json!({
  646|      0|            "message": "Backup created successfully",
  647|      0|            "backup_path": metadata.backup_path,
  648|      0|            "file_size": metadata.file_size,
  649|      0|            "created_at": metadata.created_at
  650|       |        });
  651|       |
  652|       |        Ok(CallToolResult {
  653|      0|            content: vec![Content::Text {
  654|      0|                text: serde_json::to_string_pretty(&response)?,
  655|       |            }],
  656|       |            is_error: false,
  657|       |        })
  658|      2|    }
  659|       |
  660|      2|    async fn handle_restore_database(&self, args: Value) -> Result<CallToolResult> {
  661|      2|        let backup_path = args
                          ^1
  662|      2|            .get("backup_path")
  663|      2|            .and_then(|v| v.as_str())
                                        ^1^1
  664|      2|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: backup_path"))?;
                                                         ^1                                         ^1
  665|       |
  666|      1|        let backup_file = std::path::Path::new(backup_path);
  667|      1|        self.backup_manager.restore_backup(backup_file).await?;
  668|       |
  669|      0|        let response = serde_json::json!({
  670|      0|            "message": "Database restored successfully",
  671|      0|            "backup_path": backup_path
  672|       |        });
  673|       |
  674|       |        Ok(CallToolResult {
  675|      0|            content: vec![Content::Text {
  676|      0|                text: serde_json::to_string_pretty(&response)?,
  677|       |            }],
  678|       |            is_error: false,
  679|       |        })
  680|      2|    }
  681|       |
  682|      2|    async fn handle_list_backups(&self, args: Value) -> Result<CallToolResult> {
  683|      2|        let backup_dir = args
                          ^1
  684|      2|            .get("backup_dir")
  685|      2|            .and_then(|v| v.as_str())
                                        ^1^1
  686|      2|            .ok_or_else(|| anyhow::anyhow!("Missing required parameter: backup_dir"))?;
                                                         ^1                                        ^1
  687|       |
  688|      1|        let backup_path = std::path::Path::new(backup_dir);
  689|      1|        let backups = self.backup_manager.list_backups(backup_path)?;
                                                                                 ^0
  690|       |
  691|      1|        let response = serde_json::json!({
  692|      1|            "backups": backups,
  693|      1|            "count": backups.len()
  694|       |        });
  695|       |
  696|       |        Ok(CallToolResult {
  697|      1|            content: vec![Content::Text {
  698|      1|                text: serde_json::to_string_pretty(&response)?,
                                                                           ^0
  699|       |            }],
  700|       |            is_error: false,
  701|       |        })
  702|      2|    }
  703|       |
  704|      1|    async fn handle_get_performance_stats(&self, _args: Value) -> Result<CallToolResult> {
  705|      1|        let stats = self.performance_monitor.get_all_stats();
  706|      1|        let summary = self.performance_monitor.get_summary();
  707|       |
  708|      1|        let response = serde_json::json!({
  709|      1|            "summary": summary,
  710|      1|            "operation_stats": stats
  711|       |        });
  712|       |
  713|       |        Ok(CallToolResult {
  714|      1|            content: vec![Content::Text {
  715|      1|                text: serde_json::to_string_pretty(&response)?,
                                                                           ^0
  716|       |            }],
  717|       |            is_error: false,
  718|       |        })
  719|      1|    }
  720|       |
  721|      1|    async fn handle_get_system_metrics(&self, _args: Value) -> Result<CallToolResult> {
  722|      1|        let metrics = self.performance_monitor.get_system_metrics()?;
                                                                                 ^0
  723|       |
  724|       |        Ok(CallToolResult {
  725|      1|            content: vec![Content::Text {
  726|      1|                text: serde_json::to_string_pretty(&metrics)?,
                                                                          ^0
  727|       |            }],
  728|       |            is_error: false,
  729|       |        })
  730|      1|    }
  731|       |
  732|      1|    async fn handle_get_cache_stats(&self, _args: Value) -> Result<CallToolResult> {
  733|      1|        let stats = self.cache.get_stats();
  734|       |
  735|       |        Ok(CallToolResult {
  736|      1|            content: vec![Content::Text {
  737|      1|                text: serde_json::to_string_pretty(&stats)?,
                                                                        ^0
  738|       |            }],
  739|       |            is_error: false,
  740|       |        })
  741|      1|    }
  742|       |}

/Users/garthdb/Projects/rust-things/libs/things-common/src/utils.rs:
    1|       |//! Utility functions for Things 3 integration
    2|       |
    3|       |use chrono::{DateTime, NaiveDate, Utc};
    4|       |use std::path::PathBuf;
    5|       |
    6|       |/// Get the default Things 3 database path
    7|       |#[must_use]
    8|      3|pub fn get_default_database_path() -> PathBuf {
    9|      3|    let home = std::env::var("HOME").unwrap_or_else(|_| "~".to_string());
                                                                      ^0  ^0
   10|      3|    PathBuf::from(format!(
   11|      3|        "{home}/Library/Group Containers/JLMPQHK86H.com.culturedcode.ThingsMac/ThingsData-0Z0Z2/Things Database.thingsdatabase/main.sqlite"
   12|       |    ))
   13|      3|}
   14|       |
   15|       |/// Format a date for display
   16|       |#[must_use]
   17|      6|pub fn format_date(date: &NaiveDate) -> String {
   18|      6|    date.format("%Y-%m-%d").to_string()
   19|      6|}
   20|       |
   21|       |/// Format a datetime for display
   22|       |#[must_use]
   23|      2|pub fn format_datetime(dt: &DateTime<Utc>) -> String {
   24|      2|    dt.format("%Y-%m-%d %H:%M:%S UTC").to_string()
   25|      2|}
   26|       |
   27|       |/// Parse a date string in YYYY-MM-DD format
   28|       |///
   29|       |/// # Errors
   30|       |/// Returns `chrono::ParseError` if the date string is not in the expected format
   31|     11|pub fn parse_date(date_str: &str) -> Result<NaiveDate, chrono::ParseError> {
   32|     11|    NaiveDate::parse_from_str(date_str, "%Y-%m-%d")
   33|     11|}
   34|       |
   35|       |/// Validate a UUID string
   36|       |#[must_use]
   37|     14|pub fn is_valid_uuid(uuid_str: &str) -> bool {
   38|     14|    uuid::Uuid::parse_str(uuid_str).is_ok()
   39|     14|}
   40|       |
   41|       |/// Truncate a string to a maximum length
   42|       |#[must_use]
   43|     16|pub fn truncate_string(s: &str, max_len: usize) -> String {
   44|     16|    if s.len() <= max_len {
   45|      5|        s.to_string()
   46|       |    } else {
   47|     11|        format!("{}...", &s[..max_len.saturating_sub(3)])
   48|       |    }
   49|     16|}
   50|       |
   51|       |#[cfg(test)]
   52|       |mod tests {
   53|       |    use super::*;
   54|       |    use chrono::{Datelike, NaiveDate};
   55|       |
   56|       |    #[test]
   57|      1|    fn test_get_default_database_path() {
   58|      1|        let path = get_default_database_path();
   59|       |
   60|       |        // Should contain the expected path components
   61|      1|        assert!(path.to_string_lossy().contains("Library"));
   62|      1|        assert!(path.to_string_lossy().contains("Group Containers"));
   63|      1|        assert!(path
   64|      1|            .to_string_lossy()
   65|      1|            .contains("JLMPQHK86H.com.culturedcode.ThingsMac"));
   66|      1|        assert!(path.to_string_lossy().contains("ThingsData-0Z0Z2"));
   67|      1|        assert!(path
   68|      1|            .to_string_lossy()
   69|      1|            .contains("Things Database.thingsdatabase"));
   70|      1|        assert!(path.to_string_lossy().contains("main.sqlite"));
   71|       |
   72|       |        // Should start with home directory
   73|      1|        let home = std::env::var("HOME").unwrap_or_else(|_| "~".to_string());
                                                                          ^0  ^0
   74|      1|        assert!(path.to_string_lossy().starts_with(&home));
   75|      1|    }
   76|       |
   77|       |    #[test]
   78|      1|    fn test_format_date() {
   79|      1|        let date = NaiveDate::from_ymd_opt(2023, 12, 25).unwrap();
   80|      1|        let formatted = format_date(&date);
   81|      1|        assert_eq!(formatted, "2023-12-25");
   82|      1|    }
   83|       |
   84|       |    #[test]
   85|      1|    fn test_format_date_edge_cases() {
   86|       |        // Test January 1st
   87|      1|        let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
   88|      1|        let formatted = format_date(&date);
   89|      1|        assert_eq!(formatted, "2024-01-01");
   90|       |
   91|       |        // Test December 31st
   92|      1|        let date = NaiveDate::from_ymd_opt(2023, 12, 31).unwrap();
   93|      1|        let formatted = format_date(&date);
   94|      1|        assert_eq!(formatted, "2023-12-31");
   95|       |
   96|       |        // Test leap year
   97|      1|        let date = NaiveDate::from_ymd_opt(2024, 2, 29).unwrap();
   98|      1|        let formatted = format_date(&date);
   99|      1|        assert_eq!(formatted, "2024-02-29");
  100|      1|    }
  101|       |
  102|       |    #[test]
  103|      1|    fn test_format_datetime() {
  104|      1|        let dt = Utc::now();
  105|      1|        let formatted = format_datetime(&dt);
  106|       |
  107|       |        // Should contain the expected format components
  108|      1|        assert!(formatted.contains("UTC"));
  109|      1|        assert!(formatted.contains("-"));
  110|      1|        assert!(formatted.contains(" "));
  111|      1|        assert!(formatted.contains(":"));
  112|       |
  113|       |        // Should be in the expected format
  114|      1|        assert!(formatted.len() >= 20); // At least "YYYY-MM-DD HH:MM:SS UTC"
  115|      1|    }
  116|       |
  117|       |    #[test]
  118|      1|    fn test_format_datetime_specific() {
  119|       |        // Test with a specific datetime
  120|      1|        let dt = DateTime::parse_from_rfc3339("2023-12-25T15:30:45Z")
  121|      1|            .unwrap()
  122|      1|            .with_timezone(&Utc);
  123|      1|        let formatted = format_datetime(&dt);
  124|      1|        assert_eq!(formatted, "2023-12-25 15:30:45 UTC");
  125|      1|    }
  126|       |
  127|       |    #[test]
  128|      1|    fn test_parse_date_valid() {
  129|      1|        let result = parse_date("2023-12-25");
  130|      1|        assert!(result.is_ok());
  131|      1|        let date = result.unwrap();
  132|      1|        assert_eq!(date.year(), 2023);
  133|      1|        assert_eq!(date.month(), 12);
  134|      1|        assert_eq!(date.day(), 25);
  135|      1|    }
  136|       |
  137|       |    #[test]
  138|      1|    fn test_parse_date_edge_cases() {
  139|       |        // Test January 1st
  140|      1|        let result = parse_date("2024-01-01");
  141|      1|        assert!(result.is_ok());
  142|      1|        let date = result.unwrap();
  143|      1|        assert_eq!(date.year(), 2024);
  144|      1|        assert_eq!(date.month(), 1);
  145|      1|        assert_eq!(date.day(), 1);
  146|       |
  147|       |        // Test December 31st
  148|      1|        let result = parse_date("2023-12-31");
  149|      1|        assert!(result.is_ok());
  150|      1|        let date = result.unwrap();
  151|      1|        assert_eq!(date.year(), 2023);
  152|      1|        assert_eq!(date.month(), 12);
  153|      1|        assert_eq!(date.day(), 31);
  154|       |
  155|       |        // Test leap year
  156|      1|        let result = parse_date("2024-02-29");
  157|      1|        assert!(result.is_ok());
  158|      1|        let date = result.unwrap();
  159|      1|        assert_eq!(date.year(), 2024);
  160|      1|        assert_eq!(date.month(), 2);
  161|      1|        assert_eq!(date.day(), 29);
  162|      1|    }
  163|       |
  164|       |    #[test]
  165|      1|    fn test_parse_date_invalid() {
  166|       |        // Test invalid format
  167|      1|        let result = parse_date("2023/12/25");
  168|      1|        assert!(result.is_err());
  169|       |
  170|       |        // Test invalid date
  171|      1|        let result = parse_date("2023-13-01");
  172|      1|        assert!(result.is_err());
  173|       |
  174|       |        // Test invalid day
  175|      1|        let result = parse_date("2023-02-30");
  176|      1|        assert!(result.is_err());
  177|       |
  178|       |        // Test empty string
  179|      1|        let result = parse_date("");
  180|      1|        assert!(result.is_err());
  181|       |
  182|       |        // Test malformed string
  183|      1|        let result = parse_date("not-a-date");
  184|      1|        assert!(result.is_err());
  185|      1|    }
  186|       |
  187|       |    #[test]
  188|      1|    fn test_is_valid_uuid_valid() {
  189|       |        // Test valid UUIDs
  190|      1|        assert!(is_valid_uuid("550e8400-e29b-41d4-a716-446655440000"));
  191|      1|        assert!(is_valid_uuid("6ba7b810-9dad-11d1-80b4-00c04fd430c8"));
  192|      1|        assert!(is_valid_uuid("6ba7b811-9dad-11d1-80b4-00c04fd430c8"));
  193|      1|        assert!(is_valid_uuid("00000000-0000-0000-0000-000000000000"));
  194|      1|        assert!(is_valid_uuid("ffffffff-ffff-ffff-ffff-ffffffffffff"));
  195|      1|    }
  196|       |
  197|       |    #[test]
  198|      1|    fn test_is_valid_uuid_invalid() {
  199|       |        // Test invalid UUIDs
  200|      1|        assert!(!is_valid_uuid(""));
  201|      1|        assert!(!is_valid_uuid("not-a-uuid"));
  202|      1|        assert!(!is_valid_uuid("550e8400-e29b-41d4-a716"));
  203|      1|        assert!(!is_valid_uuid("550e8400-e29b-41d4-a716-44665544000"));
  204|      1|        assert!(!is_valid_uuid("550e8400-e29b-41d4-a716-4466554400000"));
  205|      1|        assert!(!is_valid_uuid("550e8400-e29b-41d4-a716-44665544000g"));
  206|      1|        assert!(!is_valid_uuid("550e8400-e29b-41d4-a716-44665544000-"));
  207|      1|        assert!(!is_valid_uuid("550e8400-e29b-41d4-a716-44665544000 "));
  208|      1|    }
  209|       |
  210|       |    #[test]
  211|      1|    fn test_truncate_string_short() {
  212|       |        // Test string shorter than max length
  213|      1|        let result = truncate_string("hello", 10);
  214|      1|        assert_eq!(result, "hello");
  215|       |
  216|       |        // Test string equal to max length
  217|      1|        let result = truncate_string("hello", 5);
  218|      1|        assert_eq!(result, "hello");
  219|      1|    }
  220|       |
  221|       |    #[test]
  222|      1|    fn test_truncate_string_long() {
  223|       |        // Test string longer than max length
  224|      1|        let result = truncate_string("hello world", 8);
  225|      1|        assert_eq!(result, "hello...");
  226|       |
  227|       |        // Test string much longer than max length
  228|      1|        let result = truncate_string("this is a very long string", 10);
  229|      1|        assert_eq!(result, "this is...");
  230|      1|    }
  231|       |
  232|       |    #[test]
  233|      1|    fn test_truncate_string_edge_cases() {
  234|       |        // Test with max_len = 0
  235|      1|        let result = truncate_string("hello", 0);
  236|      1|        assert_eq!(result, "...");
  237|       |
  238|       |        // Test with max_len = 1
  239|      1|        let result = truncate_string("hello", 1);
  240|      1|        assert_eq!(result, "...");
  241|       |
  242|       |        // Test with max_len = 2
  243|      1|        let result = truncate_string("hello", 2);
  244|      1|        assert_eq!(result, "...");
  245|       |
  246|       |        // Test with max_len = 3
  247|      1|        let result = truncate_string("hello", 3);
  248|      1|        assert_eq!(result, "...");
  249|       |
  250|       |        // Test with max_len = 4
  251|      1|        let result = truncate_string("hello", 4);
  252|      1|        assert_eq!(result, "h...");
  253|       |
  254|       |        // Test with max_len = 5
  255|      1|        let result = truncate_string("hello", 5);
  256|      1|        assert_eq!(result, "hello");
  257|      1|    }
  258|       |
  259|       |    #[test]
  260|      1|    fn test_truncate_string_empty() {
  261|       |        // Test empty string
  262|      1|        let result = truncate_string("", 10);
  263|      1|        assert_eq!(result, "");
  264|       |
  265|       |        // Test empty string with max_len = 0
  266|      1|        let result = truncate_string("", 0);
  267|      1|        assert_eq!(result, "");
  268|      1|    }
  269|       |
  270|       |    #[test]
  271|      1|    fn test_truncate_string_unicode() {
  272|       |        // Test with unicode characters
  273|      1|        let result = truncate_string("hello ä¸–ç•Œ", 8);
  274|      1|        assert_eq!(result, "hello...");
  275|       |
  276|       |        // Test with emoji
  277|      1|        let result = truncate_string("hello ðŸ˜€", 8);
  278|      1|        assert_eq!(result, "hello...");
  279|      1|    }
  280|       |
  281|       |    #[test]
  282|      1|    fn test_truncate_string_very_long() {
  283|       |        // Test with very long string
  284|      1|        let long_string = "a".repeat(1000);
  285|      1|        let result = truncate_string(&long_string, 10);
  286|      1|        assert_eq!(result, "aaaaaaa...");
  287|      1|        assert_eq!(result.len(), 10);
  288|      1|    }
  289|       |
  290|       |    #[test]
  291|      1|    fn test_utils_integration() {
  292|       |        // Test integration between functions
  293|      1|        let date_str = "2023-12-25";
  294|      1|        let parsed_date = parse_date(date_str).unwrap();
  295|      1|        let formatted_date = format_date(&parsed_date);
  296|      1|        assert_eq!(formatted_date, date_str);
  297|       |
  298|       |        // Test UUID validation with truncation
  299|      1|        let uuid = "550e8400-e29b-41d4-a716-446655440000";
  300|      1|        assert!(is_valid_uuid(uuid));
  301|      1|        let truncated = truncate_string(uuid, 20);
  302|      1|        assert_eq!(truncated, "550e8400-e29b-41d...");
  303|      1|    }
  304|       |
  305|       |    #[test]
  306|      1|    fn test_get_default_database_path_consistency() {
  307|       |        // Test that the function returns the same path on multiple calls
  308|      1|        let path1 = get_default_database_path();
  309|      1|        let path2 = get_default_database_path();
  310|      1|        assert_eq!(path1, path2);
  311|      1|    }
  312|       |
  313|       |    #[test]
  314|      1|    fn test_format_date_consistency() {
  315|       |        // Test that formatting and parsing are consistent
  316|      1|        let date = NaiveDate::from_ymd_opt(2023, 12, 25).unwrap();
  317|      1|        let formatted = format_date(&date);
  318|      1|        let parsed = parse_date(&formatted).unwrap();
  319|      1|        assert_eq!(date, parsed);
  320|      1|    }
  321|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/backup.rs:
    1|       |//! Backup and restore functionality for Things 3 database
    2|       |
    3|       |use crate::{ThingsConfig, ThingsDatabase};
    4|       |use anyhow::Result;
    5|       |use chrono::{DateTime, Utc};
    6|       |use serde::{Deserialize, Serialize};
    7|       |use std::fs;
    8|       |use std::path::{Path, PathBuf};
    9|       |
   10|       |/// Backup metadata
   11|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   12|       |pub struct BackupMetadata {
   13|       |    pub created_at: DateTime<Utc>,
   14|       |    pub source_path: PathBuf,
   15|       |    pub backup_path: PathBuf,
   16|       |    pub file_size: u64,
   17|       |    pub version: String,
   18|       |    pub description: Option<String>,
   19|       |}
   20|       |
   21|       |/// Backup manager for Things 3 database
   22|       |pub struct BackupManager {
   23|       |    config: ThingsConfig,
   24|       |}
   25|       |
   26|       |impl BackupManager {
   27|       |    /// Create a new backup manager
   28|     51|    pub fn new(config: ThingsConfig) -> Self {
   29|     51|        Self { config }
   30|     51|    }
   31|       |
   32|       |    /// Create a backup of the Things 3 database
   33|      3|    pub async fn create_backup(
   34|      3|        &self,
   35|      3|        backup_dir: &Path,
   36|      3|        description: Option<&str>,
   37|      3|    ) -> Result<BackupMetadata> {
   38|      3|        let source_path = self.config.get_effective_database_path()?;
                          ^2                                                     ^1
   39|       |
   40|      2|        if !source_path.exists() {
   41|      0|            return Err(anyhow::anyhow!(
   42|      0|                "Source database does not exist: {:?}",
   43|      0|                source_path
   44|      0|            ));
   45|      2|        }
   46|       |
   47|       |        // Create backup directory if it doesn't exist
   48|      2|        fs::create_dir_all(backup_dir)?;
                                                    ^0
   49|       |
   50|       |        // Generate backup filename with timestamp
   51|      2|        let timestamp = Utc::now().format("%Y%m%d_%H%M%S");
   52|      2|        let backup_filename = format!("things_backup_{}.sqlite", timestamp);
   53|      2|        let backup_path = backup_dir.join(backup_filename);
   54|       |
   55|       |        // Copy the database file
   56|      2|        fs::copy(&source_path, &backup_path)?;
                                                          ^0
   57|       |
   58|       |        // Get file size
   59|      2|        let file_size = fs::metadata(&backup_path)?.len();
                                                                ^0
   60|       |
   61|       |        // Create metadata
   62|      2|        let metadata = BackupMetadata {
   63|      2|            created_at: Utc::now(),
   64|      2|            source_path: source_path.clone(),
   65|      2|            backup_path: backup_path.clone(),
   66|      2|            file_size,
   67|      2|            version: env!("CARGO_PKG_VERSION").to_string(),
   68|      2|            description: description.map(|s| s.to_string()),
   69|       |        };
   70|       |
   71|       |        // Save metadata alongside backup
   72|      2|        let metadata_path = backup_path.with_extension("json");
   73|      2|        let metadata_json = serde_json::to_string_pretty(&metadata)?;
                                                                                 ^0
   74|      2|        fs::write(&metadata_path, metadata_json)?;
                                                              ^0
   75|       |
   76|      2|        Ok(metadata)
   77|      3|    }
   78|       |
   79|       |    /// Restore from a backup
   80|      2|    pub async fn restore_backup(&self, backup_path: &Path) -> Result<()> {
   81|      2|        if !backup_path.exists() {
   82|      1|            return Err(anyhow::anyhow!(
   83|      1|                "Backup file does not exist: {:?}",
   84|      1|                backup_path
   85|      1|            ));
   86|      1|        }
   87|       |
   88|      1|        let target_path = self.config.get_effective_database_path()?;
                          ^0
   89|       |
   90|       |        // Create target directory if it doesn't exist
   91|      0|        if let Some(parent) = target_path.parent() {
   92|      0|            fs::create_dir_all(parent)?;
   93|      0|        }
   94|       |
   95|       |        // Copy backup to target location
   96|      0|        fs::copy(backup_path, &target_path)?;
   97|       |
   98|      0|        Ok(())
   99|      2|    }
  100|       |
  101|       |    /// List available backups in a directory
  102|      7|    pub fn list_backups(&self, backup_dir: &Path) -> Result<Vec<BackupMetadata>> {
  103|      7|        if !backup_dir.exists() {
  104|      3|            return Ok(vec![]);
  105|      4|        }
  106|       |
  107|      4|        let mut backups = Vec::new();
  108|       |
  109|      4|        for entry in fs::read_dir(backup_dir)? {
                          ^0                               ^0
  110|      0|            let entry = entry?;
  111|      0|            let path = entry.path();
  112|       |
  113|      0|            if path.extension().and_then(|s| s.to_str()) == Some("sqlite") {
  114|      0|                let metadata_path = path.with_extension("json");
  115|      0|                if metadata_path.exists() {
  116|      0|                    let metadata_json = fs::read_to_string(&metadata_path)?;
  117|      0|                    if let Ok(metadata) = serde_json::from_str::<BackupMetadata>(&metadata_json) {
  118|      0|                        backups.push(metadata);
  119|      0|                    }
  120|      0|                }
  121|      0|            }
  122|       |        }
  123|       |
  124|       |        // Sort by creation date (newest first)
  125|      4|        backups.sort_by(|a, b| b.created_at.cmp(&a.created_at));
                                             ^0           ^0  ^0
  126|       |
  127|      4|        Ok(backups)
  128|      7|    }
  129|       |
  130|       |    /// Get backup metadata from a backup file
  131|      1|    pub fn get_backup_metadata(&self, backup_path: &Path) -> Result<BackupMetadata> {
  132|      1|        let metadata_path = backup_path.with_extension("json");
  133|      1|        if !metadata_path.exists() {
  134|      1|            return Err(anyhow::anyhow!(
  135|      1|                "Backup metadata not found: {:?}",
  136|      1|                metadata_path
  137|      1|            ));
  138|      0|        }
  139|       |
  140|      0|        let metadata_json = fs::read_to_string(&metadata_path)?;
  141|      0|        let metadata = serde_json::from_str::<BackupMetadata>(&metadata_json)?;
  142|      0|        Ok(metadata)
  143|      1|    }
  144|       |
  145|       |    /// Delete a backup and its metadata
  146|      1|    pub fn delete_backup(&self, backup_path: &Path) -> Result<()> {
  147|      1|        if backup_path.exists() {
  148|      0|            fs::remove_file(backup_path)?;
  149|      1|        }
  150|       |
  151|      1|        let metadata_path = backup_path.with_extension("json");
  152|      1|        if metadata_path.exists() {
  153|      0|            fs::remove_file(&metadata_path)?;
  154|      1|        }
  155|       |
  156|      1|        Ok(())
  157|      1|    }
  158|       |
  159|       |    /// Clean up old backups, keeping only the specified number
  160|      2|    pub fn cleanup_old_backups(&self, backup_dir: &Path, keep_count: usize) -> Result<usize> {
  161|      2|        let mut backups = self.list_backups(backup_dir)?;
                                                                     ^0
  162|       |
  163|      2|        if backups.len() <= keep_count {
  164|      2|            return Ok(0);
  165|      0|        }
  166|       |
  167|      0|        let to_delete = backups.split_off(keep_count);
  168|      0|        let mut deleted_count = 0;
  169|       |
  170|      0|        for backup in to_delete {
  171|      0|            if let Err(e) = self.delete_backup(&backup.backup_path) {
  172|      0|                eprintln!("Failed to delete backup {:?}: {}", backup.backup_path, e);
  173|      0|            } else {
  174|      0|                deleted_count += 1;
  175|      0|            }
  176|       |        }
  177|       |
  178|      0|        Ok(deleted_count)
  179|      2|    }
  180|       |
  181|       |    /// Verify a backup by checking if it can be opened
  182|      1|    pub fn verify_backup(&self, backup_path: &Path) -> Result<bool> {
  183|      1|        if !backup_path.exists() {
  184|      1|            return Ok(false);
  185|      0|        }
  186|       |
  187|       |        // Try to open the backup as a database
  188|      0|        match ThingsDatabase::new(backup_path) {
  189|      0|            Ok(_) => Ok(true),
  190|      0|            Err(_) => Ok(false),
  191|       |        }
  192|      1|    }
  193|       |
  194|       |    /// Get backup statistics
  195|      2|    pub fn get_backup_stats(&self, backup_dir: &Path) -> Result<BackupStats> {
  196|      2|        let backups = self.list_backups(backup_dir)?;
                                                                 ^0
  197|       |
  198|      2|        let total_backups = backups.len();
  199|      2|        let total_size: u64 = backups.iter().map(|b| b.file_size).sum();
  200|      2|        let oldest_backup = backups.last().map(|b| b.created_at);
  201|      2|        let newest_backup = backups.first().map(|b| b.created_at);
  202|       |
  203|      2|        Ok(BackupStats {
  204|      2|            total_backups,
  205|      2|            total_size,
  206|      2|            oldest_backup,
  207|      2|            newest_backup,
  208|      2|        })
  209|      2|    }
  210|       |}
  211|       |
  212|       |/// Backup statistics
  213|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  214|       |pub struct BackupStats {
  215|       |    pub total_backups: usize,
  216|       |    pub total_size: u64,
  217|       |    pub oldest_backup: Option<DateTime<Utc>>,
  218|       |    pub newest_backup: Option<DateTime<Utc>>,
  219|       |}
  220|       |
  221|       |#[cfg(test)]
  222|       |mod tests {
  223|       |    use super::*;
  224|       |    use tempfile::TempDir;
  225|       |
  226|       |    #[test]
  227|      1|    fn test_backup_metadata_creation() {
  228|      1|        let now = Utc::now();
  229|      1|        let source_path = PathBuf::from("/path/to/source.db");
  230|      1|        let backup_path = PathBuf::from("/path/to/backup.db");
  231|       |
  232|      1|        let metadata = BackupMetadata {
  233|      1|            created_at: now,
  234|      1|            source_path: source_path.clone(),
  235|      1|            backup_path: backup_path.clone(),
  236|      1|            file_size: 1024,
  237|      1|            version: "1.0.0".to_string(),
  238|      1|            description: Some("Test backup".to_string()),
  239|      1|        };
  240|       |
  241|      1|        assert_eq!(metadata.source_path, source_path);
  242|      1|        assert_eq!(metadata.backup_path, backup_path);
  243|      1|        assert_eq!(metadata.file_size, 1024);
  244|      1|        assert_eq!(metadata.version, "1.0.0");
  245|      1|        assert_eq!(metadata.description, Some("Test backup".to_string()));
  246|      1|    }
  247|       |
  248|       |    #[test]
  249|      1|    fn test_backup_metadata_serialization() {
  250|      1|        let now = Utc::now();
  251|      1|        let metadata = BackupMetadata {
  252|      1|            created_at: now,
  253|      1|            source_path: PathBuf::from("/test/source.db"),
  254|      1|            backup_path: PathBuf::from("/test/backup.db"),
  255|      1|            file_size: 2048,
  256|      1|            version: "2.0.0".to_string(),
  257|      1|            description: Some("Serialization test".to_string()),
  258|      1|        };
  259|       |
  260|       |        // Test serialization
  261|      1|        let json = serde_json::to_string(&metadata).unwrap();
  262|      1|        assert!(json.contains("created_at"));
  263|      1|        assert!(json.contains("source_path"));
  264|      1|        assert!(json.contains("backup_path"));
  265|      1|        assert!(json.contains("file_size"));
  266|      1|        assert!(json.contains("version"));
  267|      1|        assert!(json.contains("description"));
  268|       |
  269|       |        // Test deserialization
  270|      1|        let deserialized: BackupMetadata = serde_json::from_str(&json).unwrap();
  271|      1|        assert_eq!(deserialized.source_path, metadata.source_path);
  272|      1|        assert_eq!(deserialized.backup_path, metadata.backup_path);
  273|      1|        assert_eq!(deserialized.file_size, metadata.file_size);
  274|      1|        assert_eq!(deserialized.version, metadata.version);
  275|      1|        assert_eq!(deserialized.description, metadata.description);
  276|      1|    }
  277|       |
  278|       |    #[test]
  279|      1|    fn test_backup_manager_new() {
  280|      1|        let config = ThingsConfig::from_env();
  281|      1|        let _backup_manager = BackupManager::new(config);
  282|       |        // Just test that it can be created
  283|       |        // Test passes if we reach this point
  284|      1|    }
  285|       |
  286|       |    #[test]
  287|      1|    fn test_backup_stats_creation() {
  288|      1|        let now = Utc::now();
  289|      1|        let stats = BackupStats {
  290|      1|            total_backups: 5,
  291|      1|            total_size: 10240,
  292|      1|            oldest_backup: Some(now - chrono::Duration::days(7)),
  293|      1|            newest_backup: Some(now),
  294|      1|        };
  295|       |
  296|      1|        assert_eq!(stats.total_backups, 5);
  297|      1|        assert_eq!(stats.total_size, 10240);
  298|      1|        assert!(stats.oldest_backup.is_some());
  299|      1|        assert!(stats.newest_backup.is_some());
  300|      1|    }
  301|       |
  302|       |    #[test]
  303|      1|    fn test_backup_stats_serialization() {
  304|      1|        let now = Utc::now();
  305|      1|        let stats = BackupStats {
  306|      1|            total_backups: 3,
  307|      1|            total_size: 5120,
  308|      1|            oldest_backup: Some(now - chrono::Duration::days(3)),
  309|      1|            newest_backup: Some(now - chrono::Duration::hours(1)),
  310|      1|        };
  311|       |
  312|       |        // Test serialization
  313|      1|        let json = serde_json::to_string(&stats).unwrap();
  314|      1|        assert!(json.contains("total_backups"));
  315|      1|        assert!(json.contains("total_size"));
  316|      1|        assert!(json.contains("oldest_backup"));
  317|      1|        assert!(json.contains("newest_backup"));
  318|       |
  319|       |        // Test deserialization
  320|      1|        let deserialized: BackupStats = serde_json::from_str(&json).unwrap();
  321|      1|        assert_eq!(deserialized.total_backups, stats.total_backups);
  322|      1|        assert_eq!(deserialized.total_size, stats.total_size);
  323|      1|    }
  324|       |
  325|       |    #[test]
  326|      1|    fn test_backup_stats_empty() {
  327|      1|        let stats = BackupStats {
  328|      1|            total_backups: 0,
  329|      1|            total_size: 0,
  330|      1|            oldest_backup: None,
  331|      1|            newest_backup: None,
  332|      1|        };
  333|       |
  334|      1|        assert_eq!(stats.total_backups, 0);
  335|      1|        assert_eq!(stats.total_size, 0);
  336|      1|        assert!(stats.oldest_backup.is_none());
  337|      1|        assert!(stats.newest_backup.is_none());
  338|      1|    }
  339|       |
  340|       |    #[test]
  341|      1|    fn test_backup_metadata_debug() {
  342|      1|        let metadata = BackupMetadata {
  343|      1|            created_at: Utc::now(),
  344|      1|            source_path: PathBuf::from("/test/source.db"),
  345|      1|            backup_path: PathBuf::from("/test/backup.db"),
  346|      1|            file_size: 1024,
  347|      1|            version: "1.0.0".to_string(),
  348|      1|            description: Some("Debug test".to_string()),
  349|      1|        };
  350|       |
  351|      1|        let debug_str = format!("{:?}", metadata);
  352|      1|        assert!(debug_str.contains("BackupMetadata"));
  353|      1|        assert!(debug_str.contains("source_path"));
  354|      1|        assert!(debug_str.contains("backup_path"));
  355|      1|    }
  356|       |
  357|       |    #[test]
  358|      1|    fn test_backup_stats_debug() {
  359|      1|        let stats = BackupStats {
  360|      1|            total_backups: 2,
  361|      1|            total_size: 2048,
  362|      1|            oldest_backup: Some(Utc::now()),
  363|      1|            newest_backup: Some(Utc::now()),
  364|      1|        };
  365|       |
  366|      1|        let debug_str = format!("{:?}", stats);
  367|      1|        assert!(debug_str.contains("BackupStats"));
  368|      1|        assert!(debug_str.contains("total_backups"));
  369|      1|        assert!(debug_str.contains("total_size"));
  370|      1|    }
  371|       |
  372|       |    #[test]
  373|      1|    fn test_backup_metadata_clone() {
  374|      1|        let metadata = BackupMetadata {
  375|      1|            created_at: Utc::now(),
  376|      1|            source_path: PathBuf::from("/test/source.db"),
  377|      1|            backup_path: PathBuf::from("/test/backup.db"),
  378|      1|            file_size: 1024,
  379|      1|            version: "1.0.0".to_string(),
  380|      1|            description: Some("Clone test".to_string()),
  381|      1|        };
  382|       |
  383|      1|        let cloned = metadata.clone();
  384|      1|        assert_eq!(metadata.source_path, cloned.source_path);
  385|      1|        assert_eq!(metadata.backup_path, cloned.backup_path);
  386|      1|        assert_eq!(metadata.file_size, cloned.file_size);
  387|      1|        assert_eq!(metadata.version, cloned.version);
  388|      1|        assert_eq!(metadata.description, cloned.description);
  389|      1|    }
  390|       |
  391|       |    #[test]
  392|      1|    fn test_backup_stats_clone() {
  393|      1|        let stats = BackupStats {
  394|      1|            total_backups: 1,
  395|      1|            total_size: 512,
  396|      1|            oldest_backup: Some(Utc::now()),
  397|      1|            newest_backup: Some(Utc::now()),
  398|      1|        };
  399|       |
  400|      1|        let cloned = stats.clone();
  401|      1|        assert_eq!(stats.total_backups, cloned.total_backups);
  402|      1|        assert_eq!(stats.total_size, cloned.total_size);
  403|      1|        assert_eq!(stats.oldest_backup, cloned.oldest_backup);
  404|      1|        assert_eq!(stats.newest_backup, cloned.newest_backup);
  405|      1|    }
  406|       |
  407|       |    #[tokio::test]
  408|      1|    async fn test_backup_creation_with_nonexistent_database() {
  409|      1|        let temp_dir = TempDir::new().unwrap();
  410|      1|        let config = ThingsConfig::from_env();
  411|      1|        let backup_manager = BackupManager::new(config);
  412|       |
  413|       |        // Test backup creation with non-existent database
  414|      1|        let result = backup_manager
  415|      1|            .create_backup(temp_dir.path(), Some("test backup"))
  416|      1|            .await;
  417|       |
  418|       |        // Should fail because database doesn't exist
  419|      1|        match result {
  420|      1|            Ok(metadata) => {
  421|      1|                // If it succeeds, verify the metadata is reasonable
  422|      1|                assert!(!metadata.backup_path.to_string_lossy().is_empty());
  423|      1|                assert!(metadata.file_size > 0);
  424|      1|            }
  425|      1|            Err(e) => {
                              ^0
  426|      1|                // If it fails, it should be because the database doesn't exist
  427|      1|                let error_msg = e.to_string();
                                  ^0          ^0^0
  428|      1|                assert!(error_msg.contains("does not exist") || error_msg.contains("not found"));
                              ^0      ^0                                      ^0
  429|      1|            }
  430|      1|        }
  431|      1|    }
  432|       |
  433|       |    #[tokio::test]
  434|      1|    async fn test_backup_creation_with_nonexistent_backup_dir() {
  435|      1|        let temp_dir = TempDir::new().unwrap();
  436|      1|        let config = ThingsConfig::from_env();
  437|      1|        let backup_manager = BackupManager::new(config);
  438|       |
  439|       |        // Test backup creation with non-existent backup directory
  440|      1|        let result = backup_manager
  441|      1|            .create_backup(temp_dir.path(), Some("test backup"))
  442|      1|            .await;
  443|       |
  444|       |        // Should either succeed or fail gracefully
  445|      1|        match result {
  446|      1|            Ok(metadata) => {
  447|      1|                // If it succeeds, verify the metadata is reasonable
  448|      1|                assert!(!metadata.backup_path.to_string_lossy().is_empty());
  449|      1|                assert!(metadata.file_size > 0);
  450|      1|            }
  451|      1|            Err(e) => {
                              ^0
  452|      1|                // If it fails, it should be because the database doesn't exist
  453|      1|                let error_msg = e.to_string();
                                  ^0          ^0^0
  454|      1|                assert!(error_msg.contains("does not exist") || error_msg.contains("not found"));
                              ^0      ^0                                      ^0
  455|      1|            }
  456|      1|        }
  457|      1|    }
  458|       |
  459|       |    #[test]
  460|      1|    fn test_backup_listing_empty_directory() {
  461|      1|        let temp_dir = TempDir::new().unwrap();
  462|      1|        let config = ThingsConfig::from_env();
  463|      1|        let backup_manager = BackupManager::new(config);
  464|       |
  465|      1|        let backups = backup_manager.list_backups(temp_dir.path()).unwrap();
  466|      1|        assert_eq!(backups.len(), 0);
  467|      1|    }
  468|       |
  469|       |    #[test]
  470|      1|    fn test_backup_listing_nonexistent_directory() {
  471|      1|        let config = ThingsConfig::from_env();
  472|      1|        let backup_manager = BackupManager::new(config);
  473|       |
  474|      1|        let backups = backup_manager
  475|      1|            .list_backups(Path::new("/nonexistent/directory"))
  476|      1|            .unwrap();
  477|      1|        assert_eq!(backups.len(), 0);
  478|      1|    }
  479|       |
  480|       |    #[test]
  481|      1|    fn test_get_backup_metadata_nonexistent() {
  482|      1|        let config = ThingsConfig::from_env();
  483|      1|        let backup_manager = BackupManager::new(config);
  484|       |
  485|      1|        let result = backup_manager.get_backup_metadata(Path::new("/nonexistent/backup.db"));
  486|      1|        assert!(result.is_err());
  487|      1|        let error_msg = result.unwrap_err().to_string();
  488|      1|        assert!(error_msg.contains("not found"));
  489|      1|    }
  490|       |
  491|       |    #[test]
  492|      1|    fn test_verify_backup_nonexistent() {
  493|      1|        let config = ThingsConfig::from_env();
  494|      1|        let backup_manager = BackupManager::new(config);
  495|       |
  496|      1|        let result = backup_manager.verify_backup(Path::new("/nonexistent/backup.db"));
  497|      1|        assert!(result.is_ok());
  498|      1|        assert!(!result.unwrap());
  499|      1|    }
  500|       |
  501|       |    #[test]
  502|      1|    fn test_delete_backup_nonexistent() {
  503|      1|        let config = ThingsConfig::from_env();
  504|      1|        let backup_manager = BackupManager::new(config);
  505|       |
  506|       |        // Should not error when trying to delete non-existent backup
  507|      1|        let result = backup_manager.delete_backup(Path::new("/nonexistent/backup.db"));
  508|      1|        assert!(result.is_ok());
  509|      1|    }
  510|       |
  511|       |    #[test]
  512|      1|    fn test_cleanup_old_backups_empty_directory() {
  513|      1|        let temp_dir = TempDir::new().unwrap();
  514|      1|        let config = ThingsConfig::from_env();
  515|      1|        let backup_manager = BackupManager::new(config);
  516|       |
  517|      1|        let deleted_count = backup_manager
  518|      1|            .cleanup_old_backups(temp_dir.path(), 5)
  519|      1|            .unwrap();
  520|      1|        assert_eq!(deleted_count, 0);
  521|      1|    }
  522|       |
  523|       |    #[test]
  524|      1|    fn test_cleanup_old_backups_nonexistent_directory() {
  525|      1|        let config = ThingsConfig::from_env();
  526|      1|        let backup_manager = BackupManager::new(config);
  527|       |
  528|      1|        let deleted_count = backup_manager
  529|      1|            .cleanup_old_backups(Path::new("/nonexistent"), 5)
  530|      1|            .unwrap();
  531|      1|        assert_eq!(deleted_count, 0);
  532|      1|    }
  533|       |
  534|       |    #[test]
  535|      1|    fn test_get_backup_stats_empty_directory() {
  536|      1|        let temp_dir = TempDir::new().unwrap();
  537|      1|        let config = ThingsConfig::from_env();
  538|      1|        let backup_manager = BackupManager::new(config);
  539|       |
  540|      1|        let stats = backup_manager.get_backup_stats(temp_dir.path()).unwrap();
  541|      1|        assert_eq!(stats.total_backups, 0);
  542|      1|        assert_eq!(stats.total_size, 0);
  543|      1|        assert!(stats.oldest_backup.is_none());
  544|      1|        assert!(stats.newest_backup.is_none());
  545|      1|    }
  546|       |
  547|       |    #[test]
  548|      1|    fn test_get_backup_stats_nonexistent_directory() {
  549|      1|        let config = ThingsConfig::from_env();
  550|      1|        let backup_manager = BackupManager::new(config);
  551|       |
  552|      1|        let stats = backup_manager
  553|      1|            .get_backup_stats(Path::new("/nonexistent"))
  554|      1|            .unwrap();
  555|      1|        assert_eq!(stats.total_backups, 0);
  556|      1|        assert_eq!(stats.total_size, 0);
  557|      1|        assert!(stats.oldest_backup.is_none());
  558|      1|        assert!(stats.newest_backup.is_none());
  559|      1|    }
  560|       |
  561|       |    #[tokio::test]
  562|      1|    async fn test_restore_backup_nonexistent() {
  563|      1|        let config = ThingsConfig::from_env();
  564|      1|        let backup_manager = BackupManager::new(config);
  565|       |
  566|      1|        let result = backup_manager
  567|      1|            .restore_backup(Path::new("/nonexistent/backup.db"))
  568|      1|            .await;
  569|      1|        assert!(result.is_err());
  570|      1|        let error_msg = result.unwrap_err().to_string();
  571|      1|        assert!(error_msg.contains("does not exist"));
  572|      1|    }
  573|       |
  574|       |    #[test]
  575|      1|    fn test_backup_metadata_without_description() {
  576|      1|        let now = Utc::now();
  577|      1|        let metadata = BackupMetadata {
  578|      1|            created_at: now,
  579|      1|            source_path: PathBuf::from("/test/source.db"),
  580|      1|            backup_path: PathBuf::from("/test/backup.db"),
  581|      1|            file_size: 1024,
  582|      1|            version: "1.0.0".to_string(),
  583|      1|            description: None,
  584|      1|        };
  585|       |
  586|      1|        assert!(metadata.description.is_none());
  587|       |
  588|       |        // Test serialization with None description
  589|      1|        let json = serde_json::to_string(&metadata).unwrap();
  590|      1|        assert!(json.contains("null")); // Should contain null for description
  591|       |
  592|       |        // Test deserialization
  593|      1|        let deserialized: BackupMetadata = serde_json::from_str(&json).unwrap();
  594|      1|        assert_eq!(deserialized.description, None);
  595|      1|    }
  596|       |
  597|       |    #[test]
  598|      1|    fn test_backup_metadata_path_operations() {
  599|      1|        let source_path = PathBuf::from("/path/to/source.db");
  600|      1|        let backup_path = PathBuf::from("/path/to/backup.db");
  601|       |
  602|      1|        let metadata = BackupMetadata {
  603|      1|            created_at: Utc::now(),
  604|      1|            source_path: source_path.clone(),
  605|      1|            backup_path: backup_path.clone(),
  606|      1|            file_size: 1024,
  607|      1|            version: "1.0.0".to_string(),
  608|      1|            description: Some("Path test".to_string()),
  609|      1|        };
  610|       |
  611|       |        // Test path operations
  612|      1|        assert_eq!(metadata.source_path.file_name().unwrap(), "source.db");
  613|      1|        assert_eq!(metadata.backup_path.file_name().unwrap(), "backup.db");
  614|      1|        assert_eq!(
  615|      1|            metadata.source_path.parent().unwrap(),
  616|      1|            Path::new("/path/to")
  617|       |        );
  618|      1|        assert_eq!(
  619|      1|            metadata.backup_path.parent().unwrap(),
  620|      1|            Path::new("/path/to")
  621|       |        );
  622|      1|    }
  623|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/cache.rs:
    1|       |//! Caching layer for frequently accessed Things 3 data
    2|       |
    3|       |use crate::models::{Area, Project, Task};
    4|       |use anyhow::Result;
    5|       |use chrono::{DateTime, Utc};
    6|       |use moka::future::Cache;
    7|       |use parking_lot::RwLock;
    8|       |use serde::{Deserialize, Serialize};
    9|       |use std::sync::Arc;
   10|       |use std::time::Duration;
   11|       |
   12|       |/// Cache configuration
   13|       |#[derive(Debug, Clone)]
   14|       |pub struct CacheConfig {
   15|       |    /// Maximum number of entries in the cache
   16|       |    pub max_capacity: u64,
   17|       |    /// Time to live for cache entries
   18|       |    pub ttl: Duration,
   19|       |    /// Time to idle for cache entries
   20|       |    pub tti: Duration,
   21|       |}
   22|       |
   23|       |impl Default for CacheConfig {
   24|     53|    fn default() -> Self {
   25|     53|        Self {
   26|     53|            max_capacity: 1000,
   27|     53|            ttl: Duration::from_secs(300), // 5 minutes
   28|     53|            tti: Duration::from_secs(60),  // 1 minute
   29|     53|        }
   30|     53|    }
   31|       |}
   32|       |
   33|       |/// Cached data wrapper
   34|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   35|       |pub struct CachedData<T> {
   36|       |    pub data: T,
   37|       |    pub cached_at: DateTime<Utc>,
   38|       |    pub expires_at: DateTime<Utc>,
   39|       |}
   40|       |
   41|       |impl<T> CachedData<T> {
   42|     29|    pub fn new(data: T, ttl: Duration) -> Self {
   43|     29|        let now = Utc::now();
   44|     29|        Self {
   45|     29|            data,
   46|     29|            cached_at: now,
   47|     29|            expires_at: now + chrono::Duration::from_std(ttl).unwrap_or_default(),
   48|     29|        }
   49|     29|    }
   50|       |
   51|     13|    pub fn is_expired(&self) -> bool {
   52|     13|        Utc::now() > self.expires_at
   53|     13|    }
   54|       |}
   55|       |
   56|       |/// Cache statistics
   57|       |#[derive(Debug, Clone, Default, Serialize, Deserialize)]
   58|       |pub struct CacheStats {
   59|       |    pub hits: u64,
   60|       |    pub misses: u64,
   61|       |    pub entries: u64,
   62|       |    pub hit_rate: f64,
   63|       |}
   64|       |
   65|       |impl CacheStats {
   66|     18|    pub fn calculate_hit_rate(&mut self) {
   67|     18|        let total = self.hits + self.misses;
   68|     18|        self.hit_rate = if total > 0 {
   69|     14|            self.hits as f64 / total as f64
   70|       |        } else {
   71|      4|            0.0
   72|       |        };
   73|     18|    }
   74|       |}
   75|       |
   76|       |/// Main cache manager for Things 3 data
   77|       |pub struct ThingsCache {
   78|       |    /// Tasks cache
   79|       |    tasks: Cache<String, CachedData<Vec<Task>>>,
   80|       |    /// Projects cache
   81|       |    projects: Cache<String, CachedData<Vec<Project>>>,
   82|       |    /// Areas cache
   83|       |    areas: Cache<String, CachedData<Vec<Area>>>,
   84|       |    /// Search results cache
   85|       |    search_results: Cache<String, CachedData<Vec<Task>>>,
   86|       |    /// Statistics
   87|       |    stats: Arc<RwLock<CacheStats>>,
   88|       |    /// Configuration
   89|       |    config: CacheConfig,
   90|       |}
   91|       |
   92|       |impl ThingsCache {
   93|       |    /// Create a new cache with the given configuration
   94|     53|    pub fn new(config: CacheConfig) -> Self {
   95|     53|        let tasks = Cache::builder()
   96|     53|            .max_capacity(config.max_capacity)
   97|     53|            .time_to_live(config.ttl)
   98|     53|            .time_to_idle(config.tti)
   99|     53|            .build();
  100|       |
  101|     53|        let projects = Cache::builder()
  102|     53|            .max_capacity(config.max_capacity)
  103|     53|            .time_to_live(config.ttl)
  104|     53|            .time_to_idle(config.tti)
  105|     53|            .build();
  106|       |
  107|     53|        let areas = Cache::builder()
  108|     53|            .max_capacity(config.max_capacity)
  109|     53|            .time_to_live(config.ttl)
  110|     53|            .time_to_idle(config.tti)
  111|     53|            .build();
  112|       |
  113|     53|        let search_results = Cache::builder()
  114|     53|            .max_capacity(config.max_capacity)
  115|     53|            .time_to_live(config.ttl)
  116|     53|            .time_to_idle(config.tti)
  117|     53|            .build();
  118|       |
  119|     53|        Self {
  120|     53|            tasks,
  121|     53|            projects,
  122|     53|            areas,
  123|     53|            search_results,
  124|     53|            stats: Arc::new(RwLock::new(CacheStats::default())),
  125|     53|            config,
  126|     53|        }
  127|     53|    }
  128|       |
  129|       |    /// Create a new cache with default configuration
  130|     51|    pub fn new_default() -> Self {
  131|     51|        Self::new(CacheConfig::default())
  132|     51|    }
  133|       |
  134|       |    /// Get tasks from cache or execute the provided function
  135|     23|    pub async fn get_tasks<F, Fut>(&self, key: &str, fetcher: F) -> Result<Vec<Task>>
  136|     23|    where
  137|     23|        F: FnOnce() -> Fut,
  138|     23|        Fut: std::future::Future<Output = Result<Vec<Task>>>,
  139|     23|    {
  140|     23|        if let Some(cached) = self.tasks.get(key).await {
                                  ^8
  141|      8|            if !cached.is_expired() {
  142|      8|                self.record_hit();
  143|      8|                return Ok(cached.data);
  144|      0|            }
  145|     15|        }
  146|       |
  147|     15|        self.record_miss();
  148|     15|        let data = fetcher().await?;
                          ^14                   ^1
  149|     14|        let cached_data = CachedData::new(data.clone(), self.config.ttl);
  150|     14|        self.tasks.insert(key.to_string(), cached_data).await;
  151|     14|        Ok(data)
  152|     23|    }
  153|       |
  154|       |    /// Get projects from cache or execute the provided function
  155|      5|    pub async fn get_projects<F, Fut>(&self, key: &str, fetcher: F) -> Result<Vec<Project>>
  156|      5|    where
  157|      5|        F: FnOnce() -> Fut,
  158|      5|        Fut: std::future::Future<Output = Result<Vec<Project>>>,
  159|      5|    {
  160|      5|        if let Some(cached) = self.projects.get(key).await {
                                  ^1
  161|      1|            if !cached.is_expired() {
  162|      1|                self.record_hit();
  163|      1|                return Ok(cached.data);
  164|      0|            }
  165|      4|        }
  166|       |
  167|      4|        self.record_miss();
  168|      4|        let data = fetcher().await?;
                                                ^0
  169|      4|        let cached_data = CachedData::new(data.clone(), self.config.ttl);
  170|      4|        self.projects.insert(key.to_string(), cached_data).await;
  171|      4|        Ok(data)
  172|      5|    }
  173|       |
  174|       |    /// Get areas from cache or execute the provided function
  175|      5|    pub async fn get_areas<F, Fut>(&self, key: &str, fetcher: F) -> Result<Vec<Area>>
  176|      5|    where
  177|      5|        F: FnOnce() -> Fut,
  178|      5|        Fut: std::future::Future<Output = Result<Vec<Area>>>,
  179|      5|    {
  180|      5|        if let Some(cached) = self.areas.get(key).await {
                                  ^1
  181|      1|            if !cached.is_expired() {
  182|      1|                self.record_hit();
  183|      1|                return Ok(cached.data);
  184|      0|            }
  185|      4|        }
  186|       |
  187|      4|        self.record_miss();
  188|      4|        let data = fetcher().await?;
                                                ^0
  189|      4|        let cached_data = CachedData::new(data.clone(), self.config.ttl);
  190|      4|        self.areas.insert(key.to_string(), cached_data).await;
  191|      4|        Ok(data)
  192|      5|    }
  193|       |
  194|       |    /// Get search results from cache or execute the provided function
  195|      5|    pub async fn get_search_results<F, Fut>(&self, key: &str, fetcher: F) -> Result<Vec<Task>>
  196|      5|    where
  197|      5|        F: FnOnce() -> Fut,
  198|      5|        Fut: std::future::Future<Output = Result<Vec<Task>>>,
  199|      5|    {
  200|      5|        if let Some(cached) = self.search_results.get(key).await {
                                  ^1
  201|      1|            if !cached.is_expired() {
  202|      1|                self.record_hit();
  203|      1|                return Ok(cached.data);
  204|      0|            }
  205|      4|        }
  206|       |
  207|      4|        self.record_miss();
  208|      4|        let data = fetcher().await?;
                                                ^0
  209|      4|        let cached_data = CachedData::new(data.clone(), self.config.ttl);
  210|      4|        self.search_results
  211|      4|            .insert(key.to_string(), cached_data)
  212|      4|            .await;
  213|      4|        Ok(data)
  214|      5|    }
  215|       |
  216|       |    /// Invalidate all caches
  217|      1|    pub async fn invalidate_all(&self) {
  218|      1|        self.tasks.invalidate_all();
  219|      1|        self.projects.invalidate_all();
  220|      1|        self.areas.invalidate_all();
  221|      1|        self.search_results.invalidate_all();
  222|      1|    }
  223|       |
  224|       |    /// Invalidate specific cache entry
  225|      1|    pub async fn invalidate(&self, key: &str) {
  226|      1|        self.tasks.remove(key).await;
  227|      1|        self.projects.remove(key).await;
  228|      1|        self.areas.remove(key).await;
  229|      1|        self.search_results.remove(key).await;
  230|      1|    }
  231|       |
  232|       |    /// Get cache statistics
  233|     16|    pub fn get_stats(&self) -> CacheStats {
  234|     16|        let mut stats = self.stats.read().clone();
  235|     16|        stats.entries = self.tasks.entry_count()
  236|     16|            + self.projects.entry_count()
  237|     16|            + self.areas.entry_count()
  238|     16|            + self.search_results.entry_count();
  239|     16|        stats.calculate_hit_rate();
  240|     16|        stats
  241|     16|    }
  242|       |
  243|       |    /// Reset cache statistics
  244|      1|    pub fn reset_stats(&self) {
  245|      1|        let mut stats = self.stats.write();
  246|      1|        *stats = CacheStats::default();
  247|      1|    }
  248|       |
  249|       |    /// Record a cache hit
  250|     11|    fn record_hit(&self) {
  251|     11|        let mut stats = self.stats.write();
  252|     11|        stats.hits += 1;
  253|     11|    }
  254|       |
  255|       |    /// Record a cache miss
  256|     27|    fn record_miss(&self) {
  257|     27|        let mut stats = self.stats.write();
  258|     27|        stats.misses += 1;
  259|     27|    }
  260|       |}
  261|       |
  262|       |/// Cache key generators
  263|       |pub mod keys {
  264|       |    /// Generate cache key for inbox tasks
  265|      3|    pub fn inbox(limit: Option<usize>) -> String {
  266|      3|        format!(
  267|      3|            "inbox:{}",
  268|      3|            limit.map_or("all".to_string(), |l| l.to_string())
                                                              ^2^2
  269|       |        )
  270|      3|    }
  271|       |
  272|       |    /// Generate cache key for today's tasks
  273|      3|    pub fn today(limit: Option<usize>) -> String {
  274|      3|        format!(
  275|      3|            "today:{}",
  276|      3|            limit.map_or("all".to_string(), |l| l.to_string())
                                                              ^2^2
  277|       |        )
  278|      3|    }
  279|       |
  280|       |    /// Generate cache key for projects
  281|      3|    pub fn projects(area_uuid: Option<&str>) -> String {
  282|      3|        format!("projects:{}", area_uuid.unwrap_or("all"))
  283|      3|    }
  284|       |
  285|       |    /// Generate cache key for areas
  286|      1|    pub fn areas() -> String {
  287|      1|        "areas:all".to_string()
  288|      1|    }
  289|       |
  290|       |    /// Generate cache key for search results
  291|      3|    pub fn search(query: &str, limit: Option<usize>) -> String {
  292|      3|        format!(
  293|      3|            "search:{}:{}",
  294|       |            query,
  295|      3|            limit.map_or("all".to_string(), |l| l.to_string())
                                                              ^2^2
  296|       |        )
  297|      3|    }
  298|       |}
  299|       |
  300|       |#[cfg(test)]
  301|       |mod tests {
  302|       |    use super::*;
  303|       |    use crate::test_utils::{create_mock_areas, create_mock_projects, create_mock_tasks};
  304|       |    use std::time::Duration;
  305|       |
  306|       |    #[test]
  307|      1|    fn test_cache_config_default() {
  308|      1|        let config = CacheConfig::default();
  309|       |
  310|      1|        assert_eq!(config.max_capacity, 1000);
  311|      1|        assert_eq!(config.ttl, Duration::from_secs(300));
  312|      1|        assert_eq!(config.tti, Duration::from_secs(60));
  313|      1|    }
  314|       |
  315|       |    #[test]
  316|      1|    fn test_cache_config_custom() {
  317|      1|        let config = CacheConfig {
  318|      1|            max_capacity: 500,
  319|      1|            ttl: Duration::from_secs(600),
  320|      1|            tti: Duration::from_secs(120),
  321|      1|        };
  322|       |
  323|      1|        assert_eq!(config.max_capacity, 500);
  324|      1|        assert_eq!(config.ttl, Duration::from_secs(600));
  325|      1|        assert_eq!(config.tti, Duration::from_secs(120));
  326|      1|    }
  327|       |
  328|       |    #[test]
  329|      1|    fn test_cached_data_creation() {
  330|      1|        let data = vec![1, 2, 3];
  331|      1|        let ttl = Duration::from_secs(60);
  332|      1|        let cached = CachedData::new(data.clone(), ttl);
  333|       |
  334|      1|        assert_eq!(cached.data, data);
  335|      1|        assert!(cached.cached_at <= Utc::now());
  336|      1|        assert!(cached.expires_at > cached.cached_at);
  337|      1|        assert!(!cached.is_expired());
  338|      1|    }
  339|       |
  340|       |    #[test]
  341|      1|    fn test_cached_data_expiration() {
  342|      1|        let data = vec![1, 2, 3];
  343|      1|        let ttl = Duration::from_millis(1);
  344|      1|        let cached = CachedData::new(data, ttl);
  345|       |
  346|       |        // Should not be expired immediately
  347|      1|        assert!(!cached.is_expired());
  348|       |
  349|       |        // Wait a bit and check again
  350|      1|        std::thread::sleep(Duration::from_millis(10));
  351|       |        // Note: This test might be flaky due to timing, but it's testing the logic
  352|      1|    }
  353|       |
  354|       |    #[test]
  355|      1|    fn test_cached_data_serialization() {
  356|      1|        let data = vec![1, 2, 3];
  357|      1|        let ttl = Duration::from_secs(60);
  358|      1|        let cached = CachedData::new(data, ttl);
  359|       |
  360|       |        // Test serialization
  361|      1|        let json = serde_json::to_string(&cached).unwrap();
  362|      1|        assert!(json.contains("data"));
  363|      1|        assert!(json.contains("cached_at"));
  364|      1|        assert!(json.contains("expires_at"));
  365|       |
  366|       |        // Test deserialization
  367|      1|        let deserialized: CachedData<Vec<i32>> = serde_json::from_str(&json).unwrap();
  368|      1|        assert_eq!(deserialized.data, cached.data);
  369|      1|    }
  370|       |
  371|       |    #[test]
  372|      1|    fn test_cache_stats_default() {
  373|      1|        let stats = CacheStats::default();
  374|       |
  375|      1|        assert_eq!(stats.hits, 0);
  376|      1|        assert_eq!(stats.misses, 0);
  377|      1|        assert_eq!(stats.entries, 0);
  378|      1|        assert_eq!(stats.hit_rate, 0.0);
  379|      1|    }
  380|       |
  381|       |    #[test]
  382|      1|    fn test_cache_stats_calculation() {
  383|      1|        let mut stats = CacheStats {
  384|      1|            hits: 8,
  385|      1|            misses: 2,
  386|      1|            entries: 5,
  387|      1|            hit_rate: 0.0,
  388|      1|        };
  389|       |
  390|      1|        stats.calculate_hit_rate();
  391|      1|        assert_eq!(stats.hit_rate, 0.8);
  392|      1|    }
  393|       |
  394|       |    #[test]
  395|      1|    fn test_cache_stats_zero_total() {
  396|      1|        let mut stats = CacheStats {
  397|      1|            hits: 0,
  398|      1|            misses: 0,
  399|      1|            entries: 0,
  400|      1|            hit_rate: 0.0,
  401|      1|        };
  402|       |
  403|      1|        stats.calculate_hit_rate();
  404|      1|        assert_eq!(stats.hit_rate, 0.0);
  405|      1|    }
  406|       |
  407|       |    #[test]
  408|      1|    fn test_cache_stats_serialization() {
  409|      1|        let stats = CacheStats {
  410|      1|            hits: 10,
  411|      1|            misses: 5,
  412|      1|            entries: 3,
  413|      1|            hit_rate: 0.67,
  414|      1|        };
  415|       |
  416|       |        // Test serialization
  417|      1|        let json = serde_json::to_string(&stats).unwrap();
  418|      1|        assert!(json.contains("hits"));
  419|      1|        assert!(json.contains("misses"));
  420|      1|        assert!(json.contains("entries"));
  421|      1|        assert!(json.contains("hit_rate"));
  422|       |
  423|       |        // Test deserialization
  424|      1|        let deserialized: CacheStats = serde_json::from_str(&json).unwrap();
  425|      1|        assert_eq!(deserialized.hits, stats.hits);
  426|      1|        assert_eq!(deserialized.misses, stats.misses);
  427|      1|        assert_eq!(deserialized.entries, stats.entries);
  428|      1|        assert_eq!(deserialized.hit_rate, stats.hit_rate);
  429|      1|    }
  430|       |
  431|       |    #[test]
  432|      1|    fn test_cache_stats_clone() {
  433|      1|        let stats = CacheStats {
  434|      1|            hits: 5,
  435|      1|            misses: 3,
  436|      1|            entries: 2,
  437|      1|            hit_rate: 0.625,
  438|      1|        };
  439|       |
  440|      1|        let cloned = stats.clone();
  441|      1|        assert_eq!(cloned.hits, stats.hits);
  442|      1|        assert_eq!(cloned.misses, stats.misses);
  443|      1|        assert_eq!(cloned.entries, stats.entries);
  444|      1|        assert_eq!(cloned.hit_rate, stats.hit_rate);
  445|      1|    }
  446|       |
  447|       |    #[test]
  448|      1|    fn test_cache_stats_debug() {
  449|      1|        let stats = CacheStats {
  450|      1|            hits: 1,
  451|      1|            misses: 1,
  452|      1|            entries: 1,
  453|      1|            hit_rate: 0.5,
  454|      1|        };
  455|       |
  456|      1|        let debug_str = format!("{:?}", stats);
  457|      1|        assert!(debug_str.contains("CacheStats"));
  458|      1|        assert!(debug_str.contains("hits"));
  459|      1|        assert!(debug_str.contains("misses"));
  460|      1|    }
  461|       |
  462|       |    #[tokio::test]
  463|      1|    async fn test_cache_new() {
  464|      1|        let config = CacheConfig::default();
  465|      1|        let _cache = ThingsCache::new(config);
  466|       |
  467|       |        // Just test that it can be created
  468|       |        // Test passes if we reach this point
  469|      1|    }
  470|       |
  471|       |    #[tokio::test]
  472|      1|    async fn test_cache_new_default() {
  473|      1|        let _cache = ThingsCache::new_default();
  474|       |
  475|       |        // Just test that it can be created
  476|       |        // Test passes if we reach this point
  477|      1|    }
  478|       |
  479|       |    #[tokio::test]
  480|      1|    async fn test_cache_basic_operations() {
  481|      1|        let cache = ThingsCache::new_default();
  482|       |
  483|       |        // Test cache miss
  484|      2|        let result = cache.get_tasks("test", || async { Ok(vec![]) }).await;
                          ^1       ^1    ^1        ^1               ^1^1            ^1
  485|      1|        assert!(result.is_ok());
  486|       |
  487|       |        // Test cache hit
  488|      1|        let result = cache.get_tasks("test", || async { Ok(vec![]) }).await;
                                                                    ^0^0         ^0
  489|      1|        assert!(result.is_ok());
  490|       |
  491|      1|        let stats = cache.get_stats();
  492|      1|        assert_eq!(stats.hits, 1);
  493|      1|        assert_eq!(stats.misses, 1);
  494|      1|    }
  495|       |
  496|       |    #[tokio::test]
  497|      1|    async fn test_cache_tasks_with_data() {
  498|      1|        let cache = ThingsCache::new_default();
  499|      1|        let mock_tasks = create_mock_tasks();
  500|       |
  501|       |        // Test cache miss with data
  502|      1|        let result = cache
  503|      2|            .get_tasks("tasks", || async { Ok(mock_tasks.clone()) })
                           ^1        ^1                ^1^1
  504|      1|            .await;
  505|      1|        assert!(result.is_ok());
  506|      1|        assert_eq!(result.unwrap().len(), mock_tasks.len());
  507|       |
  508|       |        // Test cache hit
  509|      1|        let result = cache.get_tasks("tasks", || async { Ok(vec![]) }).await;
                                                                     ^0^0         ^0
  510|      1|        assert!(result.is_ok());
  511|      1|        assert_eq!(result.unwrap().len(), mock_tasks.len());
  512|       |
  513|      1|        let stats = cache.get_stats();
  514|      1|        assert_eq!(stats.hits, 1);
  515|      1|        assert_eq!(stats.misses, 1);
  516|      1|    }
  517|       |
  518|       |    #[tokio::test]
  519|      1|    async fn test_cache_projects() {
  520|      1|        let cache = ThingsCache::new_default();
  521|      1|        let mock_projects = create_mock_projects();
  522|       |
  523|       |        // Test cache miss
  524|      1|        let result = cache
  525|      2|            .get_projects("projects", || async { Ok(mock_projects.clone()) })
                           ^1           ^1                   ^1^1
  526|      1|            .await;
  527|      1|        assert!(result.is_ok());
  528|       |
  529|       |        // Test cache hit
  530|      1|        let result = cache
  531|      1|            .get_projects("projects", || async { Ok(vec![]) })
                                                             ^0^0         ^0
  532|      1|            .await;
  533|      1|        assert!(result.is_ok());
  534|       |
  535|      1|        let stats = cache.get_stats();
  536|      1|        assert_eq!(stats.hits, 1);
  537|      1|        assert_eq!(stats.misses, 1);
  538|      1|    }
  539|       |
  540|       |    #[tokio::test]
  541|      1|    async fn test_cache_areas() {
  542|      1|        let cache = ThingsCache::new_default();
  543|      1|        let mock_areas = create_mock_areas();
  544|       |
  545|       |        // Test cache miss
  546|      1|        let result = cache
  547|      2|            .get_areas("areas", || async { Ok(mock_areas.clone()) })
                           ^1        ^1                ^1^1
  548|      1|            .await;
  549|      1|        assert!(result.is_ok());
  550|       |
  551|       |        // Test cache hit
  552|      1|        let result = cache.get_areas("areas", || async { Ok(vec![]) }).await;
                                                                     ^0^0         ^0
  553|      1|        assert!(result.is_ok());
  554|       |
  555|      1|        let stats = cache.get_stats();
  556|      1|        assert_eq!(stats.hits, 1);
  557|      1|        assert_eq!(stats.misses, 1);
  558|      1|    }
  559|       |
  560|       |    #[tokio::test]
  561|      1|    async fn test_cache_search_results() {
  562|      1|        let cache = ThingsCache::new_default();
  563|      1|        let mock_tasks = create_mock_tasks();
  564|       |
  565|       |        // Test cache miss
  566|      1|        let result = cache
  567|      2|            .get_search_results("search:test", || async { Ok(mock_tasks.clone()) })
                           ^1                 ^1                      ^1^1
  568|      1|            .await;
  569|      1|        assert!(result.is_ok());
  570|       |
  571|       |        // Test cache hit
  572|      1|        let result = cache
  573|      1|            .get_search_results("search:test", || async { Ok(vec![]) })
                                                                      ^0^0         ^0
  574|      1|            .await;
  575|      1|        assert!(result.is_ok());
  576|       |
  577|      1|        let stats = cache.get_stats();
  578|      1|        assert_eq!(stats.hits, 1);
  579|      1|        assert_eq!(stats.misses, 1);
  580|      1|    }
  581|       |
  582|       |    #[tokio::test]
  583|      1|    async fn test_cache_fetcher_error() {
  584|      1|        let cache = ThingsCache::new_default();
  585|       |
  586|       |        // Test that fetcher errors are propagated
  587|      1|        let result = cache
  588|      2|            .get_tasks("error", || async { Err(anyhow::anyhow!("Test error")) })
                           ^1        ^1                ^1^1
  589|      1|            .await;
  590|       |
  591|      1|        assert!(result.is_err());
  592|      1|        assert!(result.unwrap_err().to_string().contains("Test error"));
  593|       |
  594|      1|        let stats = cache.get_stats();
  595|      1|        assert_eq!(stats.hits, 0);
  596|      1|        assert_eq!(stats.misses, 1);
  597|      1|    }
  598|       |
  599|       |    #[tokio::test]
  600|      1|    async fn test_cache_expiration() {
  601|      1|        let config = CacheConfig {
  602|      1|            max_capacity: 100,
  603|      1|            ttl: Duration::from_millis(10),
  604|      1|            tti: Duration::from_millis(5),
  605|      1|        };
  606|      1|        let cache = ThingsCache::new(config);
  607|       |
  608|       |        // Insert data
  609|      2|        let _ = cache.get_tasks("test", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1               ^1^1            ^1
  610|       |
  611|       |        // Wait for expiration
  612|      1|        tokio::time::sleep(Duration::from_millis(20)).await;
  613|       |
  614|       |        // Should be a miss due to expiration
  615|      2|        let _ = cache.get_tasks("test", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1               ^1^1            ^1
  616|       |
  617|      1|        let stats = cache.get_stats();
  618|      1|        assert_eq!(stats.misses, 2);
  619|      1|    }
  620|       |
  621|       |    #[tokio::test]
  622|      1|    async fn test_cache_invalidate_all() {
  623|      1|        let cache = ThingsCache::new_default();
  624|       |
  625|       |        // Insert data into all caches
  626|      2|        let _ = cache.get_tasks("tasks", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1                ^1^1            ^1
  627|      1|        let _ = cache
  628|      2|            .get_projects("projects", || async { Ok(vec![]) })
                           ^1           ^1                   ^1^1
  629|      1|            .await;
  630|      2|        let _ = cache.get_areas("areas", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1                ^1^1            ^1
  631|      1|        let _ = cache
  632|      2|            .get_search_results("search", || async { Ok(vec![]) })
                           ^1                 ^1                 ^1^1
  633|      1|            .await;
  634|       |
  635|       |        // Invalidate all
  636|      1|        cache.invalidate_all().await;
  637|       |
  638|       |        // All should be misses now
  639|      2|        let _ = cache.get_tasks("tasks", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1                ^1^1            ^1
  640|      1|        let _ = cache
  641|      2|            .get_projects("projects", || async { Ok(vec![]) })
                           ^1           ^1                   ^1^1
  642|      1|            .await;
  643|      2|        let _ = cache.get_areas("areas", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1                ^1^1            ^1
  644|      1|        let _ = cache
  645|      2|            .get_search_results("search", || async { Ok(vec![]) })
                           ^1                 ^1                 ^1^1
  646|      1|            .await;
  647|       |
  648|      1|        let stats = cache.get_stats();
  649|      1|        assert_eq!(stats.misses, 8); // 4 initial + 4 after invalidation
  650|      1|    }
  651|       |
  652|       |    #[tokio::test]
  653|      1|    async fn test_cache_invalidate_specific() {
  654|      1|        let cache = ThingsCache::new_default();
  655|       |
  656|       |        // Insert data
  657|      2|        let _ = cache.get_tasks("key1", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1               ^1^1            ^1
  658|      2|        let _ = cache.get_tasks("key2", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1               ^1^1            ^1
  659|       |
  660|       |        // Invalidate specific key
  661|      1|        cache.invalidate("key1").await;
  662|       |
  663|       |        // key1 should be a miss, key2 should be a hit
  664|      2|        let _ = cache.get_tasks("key1", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1               ^1^1            ^1
  665|      1|        let _ = cache.get_tasks("key2", || async { Ok(vec![]) }).await;
                                                               ^0^0         ^0
  666|       |
  667|      1|        let stats = cache.get_stats();
  668|      1|        assert_eq!(stats.hits, 1); // key2 hit
  669|      1|        assert_eq!(stats.misses, 3); // key1 initial + key1 after invalidation + key2 initial
  670|      1|    }
  671|       |
  672|       |    #[tokio::test]
  673|      1|    async fn test_cache_reset_stats() {
  674|      1|        let cache = ThingsCache::new_default();
  675|       |
  676|       |        // Generate some stats
  677|      2|        let _ = cache.get_tasks("test", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1               ^1^1            ^1
  678|      1|        let _ = cache.get_tasks("test", || async { Ok(vec![]) }).await;
                                                               ^0^0         ^0
  679|       |
  680|      1|        let stats_before = cache.get_stats();
  681|      1|        assert!(stats_before.hits > 0 || stats_before.misses > 0);
                                                       ^0
  682|       |
  683|       |        // Reset stats
  684|      1|        cache.reset_stats();
  685|       |
  686|      1|        let stats_after = cache.get_stats();
  687|      1|        assert_eq!(stats_after.hits, 0);
  688|      1|        assert_eq!(stats_after.misses, 0);
  689|      1|        assert_eq!(stats_after.hit_rate, 0.0);
  690|      1|    }
  691|       |
  692|       |    #[test]
  693|      1|    fn test_cache_keys_inbox() {
  694|      1|        assert_eq!(keys::inbox(None), "inbox:all");
  695|      1|        assert_eq!(keys::inbox(Some(10)), "inbox:10");
  696|      1|        assert_eq!(keys::inbox(Some(0)), "inbox:0");
  697|      1|    }
  698|       |
  699|       |    #[test]
  700|      1|    fn test_cache_keys_today() {
  701|      1|        assert_eq!(keys::today(None), "today:all");
  702|      1|        assert_eq!(keys::today(Some(5)), "today:5");
  703|      1|        assert_eq!(keys::today(Some(100)), "today:100");
  704|      1|    }
  705|       |
  706|       |    #[test]
  707|      1|    fn test_cache_keys_projects() {
  708|      1|        assert_eq!(keys::projects(None), "projects:all");
  709|      1|        assert_eq!(keys::projects(Some("uuid-123")), "projects:uuid-123");
  710|      1|        assert_eq!(keys::projects(Some("")), "projects:");
  711|      1|    }
  712|       |
  713|       |    #[test]
  714|      1|    fn test_cache_keys_areas() {
  715|      1|        assert_eq!(keys::areas(), "areas:all");
  716|      1|    }
  717|       |
  718|       |    #[test]
  719|      1|    fn test_cache_keys_search() {
  720|      1|        assert_eq!(keys::search("test query", None), "search:test query:all");
  721|      1|        assert_eq!(keys::search("test query", Some(10)), "search:test query:10");
  722|      1|        assert_eq!(keys::search("", Some(5)), "search::5");
  723|      1|    }
  724|       |
  725|       |    #[tokio::test]
  726|      1|    async fn test_cache_multiple_keys() {
  727|      1|        let cache = ThingsCache::new_default();
  728|      1|        let mock_tasks1 = create_mock_tasks();
  729|      1|        let mock_tasks2 = create_mock_tasks();
  730|       |
  731|       |        // Test different keys don't interfere
  732|      1|        let _ = cache
  733|      2|            .get_tasks("key1", || async { Ok(mock_tasks1.clone()) })
                           ^1        ^1               ^1^1
  734|      1|            .await;
  735|      1|        let _ = cache
  736|      2|            .get_tasks("key2", || async { Ok(mock_tasks2.clone()) })
                           ^1        ^1               ^1^1
  737|      1|            .await;
  738|       |
  739|       |        // Both should be hits
  740|      1|        let result1 = cache
  741|      1|            .get_tasks("key1", || async { Ok(vec![]) })
                                                      ^0^0         ^0
  742|      1|            .await
  743|      1|            .unwrap();
  744|      1|        let result2 = cache
  745|      1|            .get_tasks("key2", || async { Ok(vec![]) })
                                                      ^0^0         ^0
  746|      1|            .await
  747|      1|            .unwrap();
  748|       |
  749|      1|        assert_eq!(result1.len(), mock_tasks1.len());
  750|      1|        assert_eq!(result2.len(), mock_tasks2.len());
  751|       |
  752|      1|        let stats = cache.get_stats();
  753|      1|        assert_eq!(stats.hits, 2);
  754|      1|        assert_eq!(stats.misses, 2);
  755|      1|    }
  756|       |
  757|       |    #[tokio::test]
  758|      1|    async fn test_cache_entry_count() {
  759|      1|        let cache = ThingsCache::new_default();
  760|       |
  761|       |        // Initially no entries
  762|      1|        let stats = cache.get_stats();
  763|      1|        assert_eq!(stats.entries, 0);
  764|       |
  765|       |        // Add some entries
  766|      2|        let _ = cache.get_tasks("tasks", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1                ^1^1            ^1
  767|      1|        let _ = cache
  768|      2|            .get_projects("projects", || async { Ok(vec![]) })
                           ^1           ^1                   ^1^1
  769|      1|            .await;
  770|      2|        let _ = cache.get_areas("areas", || async { Ok(vec![]) }).await;
                              ^1    ^1        ^1                ^1^1            ^1
  771|      1|        let _ = cache
  772|      2|            .get_search_results("search", || async { Ok(vec![]) })
                           ^1                 ^1                 ^1^1
  773|      1|            .await;
  774|       |
  775|       |        // The entry count might not be immediately updated due to async nature
  776|       |        // Let's just verify that we can get stats without panicking
  777|      1|        let stats = cache.get_stats();
  778|       |        // Verify stats can be retrieved without panicking
  779|      1|        let _ = stats.entries;
  780|      1|    }
  781|       |
  782|       |    #[tokio::test]
  783|      1|    async fn test_cache_hit_rate_calculation() {
  784|      1|        let cache = ThingsCache::new_default();
  785|       |
  786|       |        // Generate some hits and misses
  787|      2|        let _ = cache.get_tasks("test", || async { Ok(vec![]) }).await; // miss
                              ^1    ^1        ^1               ^1^1            ^1
  788|      1|        let _ = cache.get_tasks("test", || async { Ok(vec![]) }).await; // hit
                                                               ^0^0         ^0
  789|      1|        let _ = cache.get_tasks("test", || async { Ok(vec![]) }).await; // hit
                                                               ^0^0         ^0
  790|       |
  791|      1|        let stats = cache.get_stats();
  792|      1|        assert_eq!(stats.hits, 2);
  793|      1|        assert_eq!(stats.misses, 1);
  794|      1|        assert!((stats.hit_rate - 2.0 / 3.0).abs() < 0.001);
  795|      1|    }
  796|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/config.rs:
    1|       |//! Configuration management for Things 3 integration
    2|       |
    3|       |use crate::error::{Result, ThingsError};
    4|       |use std::path::{Path, PathBuf};
    5|       |
    6|       |/// Configuration for Things 3 database access
    7|       |#[derive(Debug, Clone)]
    8|       |pub struct ThingsConfig {
    9|       |    /// Path to the Things 3 database
   10|       |    pub database_path: PathBuf,
   11|       |    /// Whether to use the default database path if the specified path doesn't exist
   12|       |    pub fallback_to_default: bool,
   13|       |}
   14|       |
   15|       |impl ThingsConfig {
   16|       |    /// Create a new configuration with a custom database path
   17|       |    ///
   18|       |    /// # Arguments
   19|       |    /// * `database_path` - Path to the Things 3 database
   20|       |    /// * `fallback_to_default` - Whether to fall back to the default path if the specified path doesn't exist
   21|       |    #[must_use]
   22|     72|    pub fn new<P: AsRef<Path>>(database_path: P, fallback_to_default: bool) -> Self {
   23|     72|        Self {
   24|     72|            database_path: database_path.as_ref().to_path_buf(),
   25|     72|            fallback_to_default,
   26|     72|        }
   27|     72|    }
   28|       |
   29|       |    /// Create a configuration with the default database path
   30|       |    #[must_use]
   31|      1|    pub fn with_default_path() -> Self {
   32|      1|        Self {
   33|      1|            database_path: Self::get_default_database_path(),
   34|      1|            fallback_to_default: false,
   35|      1|        }
   36|      1|    }
   37|       |
   38|       |    /// Get the effective database path, falling back to default if needed
   39|       |    ///
   40|       |    /// # Errors
   41|       |    /// Returns `ThingsError::Message` if neither the specified path nor the default path exists
   42|     10|    pub fn get_effective_database_path(&self) -> Result<PathBuf> {
   43|       |        // Check if the specified path exists
   44|     10|        if self.database_path.exists() {
   45|      5|            return Ok(self.database_path.clone());
   46|      5|        }
   47|       |
   48|       |        // If fallback is enabled, try the default path
   49|      5|        if self.fallback_to_default {
   50|      1|            let default_path = Self::get_default_database_path();
   51|      1|            if default_path.exists() {
   52|      1|                return Ok(default_path);
   53|      0|            }
   54|      4|        }
   55|       |
   56|      4|        Err(ThingsError::configuration(format!(
   57|      4|            "Database not found at {} and fallback is {}",
   58|      4|            self.database_path.display(),
   59|      4|            if self.fallback_to_default {
   60|      0|                "disabled"
   61|       |            } else {
   62|      4|                "enabled but default path also not found"
   63|       |            }
   64|       |        )))
   65|     10|    }
   66|       |
   67|       |    /// Get the default Things 3 database path
   68|       |    #[must_use]
   69|     19|    pub fn get_default_database_path() -> PathBuf {
   70|     19|        let home = std::env::var("HOME").unwrap_or_else(|_| "~".to_string());
                                                                          ^0  ^0
   71|     19|        PathBuf::from(format!(
   72|     19|            "{home}/Library/Group Containers/JLMPQHK86H.com.culturedcode.ThingsMac/ThingsData-0Z0Z2/Things Database.thingsdatabase/main.sqlite"
   73|       |        ))
   74|     19|    }
   75|       |
   76|       |    /// Create configuration from environment variables
   77|       |    ///
   78|       |    /// Reads `THINGS_DATABASE_PATH` and `THINGS_FALLBACK_TO_DEFAULT` environment variables
   79|       |    #[must_use]
   80|     18|    pub fn from_env() -> Self {
   81|     18|        let database_path = std::env::var("THINGS_DATABASE_PATH")
   82|     18|            .map_or_else(|_| Self::get_default_database_path(), PathBuf::from);
                                           ^14
   83|       |
   84|     18|        let fallback_to_default = std::env::var("THINGS_FALLBACK_TO_DEFAULT")
   85|     18|            .map(|v| v.to_lowercase() == "true" || v == "1")
                                   ^4                            ^2
   86|     18|            .unwrap_or(true);
   87|       |
   88|     18|        Self::new(database_path, fallback_to_default)
   89|     18|    }
   90|       |
   91|       |    /// Create configuration for testing with a temporary database
   92|       |    ///
   93|       |    /// # Errors
   94|       |    /// Returns `ThingsError::Io` if the temporary file cannot be created
   95|      0|    pub fn for_testing() -> Result<Self> {
   96|       |        use tempfile::NamedTempFile;
   97|      0|        let temp_file = NamedTempFile::new()?;
   98|      0|        let db_path = temp_file.path().to_path_buf();
   99|      0|        Ok(Self::new(db_path, false))
  100|      0|    }
  101|       |}
  102|       |
  103|       |impl Default for ThingsConfig {
  104|      1|    fn default() -> Self {
  105|      1|        Self::with_default_path()
  106|      1|    }
  107|       |}
  108|       |
  109|       |#[cfg(test)]
  110|       |mod tests {
  111|       |    use super::*;
  112|       |    use tempfile::NamedTempFile;
  113|       |
  114|       |    #[test]
  115|      1|    fn test_config_creation() {
  116|      1|        let config = ThingsConfig::new("/path/to/db.sqlite", true);
  117|      1|        assert_eq!(config.database_path, PathBuf::from("/path/to/db.sqlite"));
  118|      1|        assert!(config.fallback_to_default);
  119|      1|    }
  120|       |
  121|       |    #[test]
  122|      1|    fn test_default_config() {
  123|      1|        let config = ThingsConfig::default();
  124|      1|        assert!(config
  125|      1|            .database_path
  126|      1|            .to_string_lossy()
  127|      1|            .contains("Things Database.thingsdatabase"));
  128|      1|        assert!(!config.fallback_to_default);
  129|      1|    }
  130|       |
  131|       |    #[test]
  132|      1|    fn test_config_from_env() {
  133|      1|        std::env::set_var("THINGS_DATABASE_PATH", "/custom/path/db.sqlite");
  134|      1|        std::env::set_var("THINGS_FALLBACK_TO_DEFAULT", "true");
  135|       |
  136|      1|        let config = ThingsConfig::from_env();
  137|      1|        assert_eq!(
  138|       |            config.database_path,
  139|      1|            PathBuf::from("/custom/path/db.sqlite")
  140|       |        );
  141|      1|        assert!(config.fallback_to_default);
  142|       |
  143|       |        // Clean up
  144|      1|        std::env::remove_var("THINGS_DATABASE_PATH");
  145|      1|        std::env::remove_var("THINGS_FALLBACK_TO_DEFAULT");
  146|      1|    }
  147|       |
  148|       |    #[test]
  149|      1|    fn test_effective_database_path() {
  150|       |        // Test with existing file
  151|      1|        let temp_file = NamedTempFile::new().unwrap();
  152|      1|        let db_path = temp_file.path();
  153|      1|        let config = ThingsConfig::new(db_path, false);
  154|       |
  155|      1|        let effective_path = config.get_effective_database_path().unwrap();
  156|      1|        assert_eq!(effective_path, db_path);
  157|      1|    }
  158|       |
  159|       |    #[test]
  160|      1|    fn test_fallback_behavior() {
  161|       |        // Test fallback when it should succeed (default path exists)
  162|      1|        let config = ThingsConfig::new("/nonexistent/path.sqlite", true);
  163|      1|        let result = config.get_effective_database_path();
  164|       |
  165|       |        // If the default path exists, fallback should succeed
  166|      1|        if ThingsConfig::get_default_database_path().exists() {
  167|      1|            assert!(result.is_ok());
  168|      1|            assert_eq!(result.unwrap(), ThingsConfig::get_default_database_path());
  169|       |        } else {
  170|       |            // If default path doesn't exist, should get an error
  171|      0|            assert!(result.is_err());
  172|       |        }
  173|      1|    }
  174|       |
  175|       |    #[test]
  176|      1|    fn test_fallback_disabled() {
  177|       |        // Test when fallback is disabled - should always fail if path doesn't exist
  178|      1|        let config = ThingsConfig::new("/nonexistent/path.sqlite", false);
  179|      1|        let result = config.get_effective_database_path();
  180|       |
  181|       |        // Should always fail when fallback is disabled and path doesn't exist
  182|      1|        assert!(result.is_err());
  183|      1|    }
  184|       |
  185|       |    #[test]
  186|      1|    fn test_config_with_fallback_enabled() {
  187|      1|        let config = ThingsConfig::new("/nonexistent/path", true);
  188|      1|        assert_eq!(config.database_path, PathBuf::from("/nonexistent/path"));
  189|      1|        assert!(config.fallback_to_default);
  190|      1|    }
  191|       |
  192|       |    #[test]
  193|      1|    fn test_config_from_env_with_custom_path() {
  194|       |        // Save original values
  195|      1|        let original_db_path = std::env::var("THINGS_DATABASE_PATH").ok();
  196|      1|        let original_fallback = std::env::var("THINGS_FALLBACK_TO_DEFAULT").ok();
  197|       |
  198|      1|        std::env::set_var("THINGS_DATABASE_PATH", "/env/custom/path");
  199|      1|        std::env::set_var("THINGS_FALLBACK_TO_DEFAULT", "false");
  200|      1|        let config = ThingsConfig::from_env();
  201|      1|        assert_eq!(config.database_path, PathBuf::from("/env/custom/path"));
  202|      1|        assert!(!config.fallback_to_default);
  203|       |
  204|       |        // Restore original values
  205|      1|        if let Some(path) = original_db_path {
                                  ^0
  206|      0|            std::env::set_var("THINGS_DATABASE_PATH", path);
  207|      1|        } else {
  208|      1|            std::env::remove_var("THINGS_DATABASE_PATH");
  209|      1|        }
  210|      1|        if let Some(fallback) = original_fallback {
                                  ^0
  211|      0|            std::env::set_var("THINGS_FALLBACK_TO_DEFAULT", fallback);
  212|      1|        } else {
  213|      1|            std::env::remove_var("THINGS_FALLBACK_TO_DEFAULT");
  214|      1|        }
  215|      1|    }
  216|       |
  217|       |    #[test]
  218|      1|    fn test_config_from_env_with_fallback() {
  219|       |        // Save original values
  220|      1|        let original_db_path = std::env::var("THINGS_DATABASE_PATH").ok();
  221|      1|        let original_fallback = std::env::var("THINGS_FALLBACK_TO_DEFAULT").ok();
  222|       |        
  223|       |        // Set test values
  224|      1|        std::env::set_var("THINGS_DATABASE_PATH", "/env/path");
  225|      1|        std::env::set_var("THINGS_FALLBACK_TO_DEFAULT", "true");
  226|       |        
  227|      1|        let config = ThingsConfig::from_env();
  228|      1|        assert_eq!(config.database_path, PathBuf::from("/env/path"));
  229|      1|        assert!(config.fallback_to_default);
  230|       |        
  231|       |        // Restore original values
  232|      1|        if let Some(db_path) = original_db_path {
                                  ^0
  233|      0|            std::env::set_var("THINGS_DATABASE_PATH", db_path);
  234|      1|        } else {
  235|      1|            std::env::remove_var("THINGS_DATABASE_PATH");
  236|      1|        }
  237|       |        
  238|      1|        if let Some(fallback) = original_fallback {
                                  ^0
  239|      0|            std::env::set_var("THINGS_FALLBACK_TO_DEFAULT", fallback);
  240|      1|        } else {
  241|      1|            std::env::remove_var("THINGS_FALLBACK_TO_DEFAULT");
  242|      1|        }
  243|      1|    }
  244|       |
  245|       |    #[test]
  246|      1|    fn test_config_from_env_with_invalid_fallback() {
  247|       |        // Save original values
  248|      1|        let original_db_path = std::env::var("THINGS_DATABASE_PATH").ok();
  249|      1|        let original_fallback = std::env::var("THINGS_FALLBACK_TO_DEFAULT").ok();
  250|       |
  251|      1|        std::env::set_var("THINGS_DATABASE_PATH", "/env/path");
  252|      1|        std::env::set_var("THINGS_FALLBACK_TO_DEFAULT", "invalid");
  253|      1|        let config = ThingsConfig::from_env();
  254|      1|        assert_eq!(config.database_path, PathBuf::from("/env/path"));
  255|      1|        assert!(!config.fallback_to_default); // Should default to false for invalid value
  256|       |
  257|       |        // Restore original values
  258|      1|        if let Some(path) = original_db_path {
                                  ^0
  259|      0|            std::env::set_var("THINGS_DATABASE_PATH", path);
  260|      1|        } else {
  261|      1|            std::env::remove_var("THINGS_DATABASE_PATH");
  262|      1|        }
  263|      1|        if let Some(fallback) = original_fallback {
                                  ^0
  264|      0|            std::env::set_var("THINGS_FALLBACK_TO_DEFAULT", fallback);
  265|      1|        } else {
  266|      1|            std::env::remove_var("THINGS_FALLBACK_TO_DEFAULT");
  267|      1|        }
  268|      1|    }
  269|       |
  270|       |    #[test]
  271|      1|    fn test_config_debug_formatting() {
  272|      1|        let config = ThingsConfig::new("/test/path", true);
  273|      1|        let debug_str = format!("{:?}", config);
  274|      1|        assert!(debug_str.contains("/test/path"));
  275|      1|        assert!(debug_str.contains("true"));
  276|      1|    }
  277|       |
  278|       |    #[test]
  279|      1|    fn test_config_clone() {
  280|      1|        let config1 = ThingsConfig::new("/test/path", true);
  281|      1|        let config2 = config1.clone();
  282|       |
  283|      1|        assert_eq!(config1.database_path, config2.database_path);
  284|      1|        assert_eq!(config1.fallback_to_default, config2.fallback_to_default);
  285|      1|    }
  286|       |
  287|       |    #[test]
  288|      1|    fn test_config_with_different_path_types() {
  289|       |        // Test with relative path
  290|      1|        let config = ThingsConfig::new("relative/path", false);
  291|      1|        assert_eq!(config.database_path, PathBuf::from("relative/path"));
  292|       |
  293|       |        // Test with absolute path
  294|      1|        let config = ThingsConfig::new("/absolute/path", false);
  295|      1|        assert_eq!(config.database_path, PathBuf::from("/absolute/path"));
  296|       |
  297|       |        // Test with current directory
  298|      1|        let config = ThingsConfig::new(".", false);
  299|      1|        assert_eq!(config.database_path, PathBuf::from("."));
  300|      1|    }
  301|       |
  302|       |    #[test]
  303|      1|    fn test_config_edge_cases() {
  304|       |        // Test with empty string path
  305|      1|        let config = ThingsConfig::new("", false);
  306|      1|        assert_eq!(config.database_path, PathBuf::from(""));
  307|       |
  308|       |        // Test with very long path
  309|      1|        let long_path = "/".repeat(1000);
  310|      1|        let config = ThingsConfig::new(&long_path, false);
  311|      1|        assert_eq!(config.database_path, PathBuf::from(&long_path));
  312|      1|    }
  313|       |
  314|       |    #[test]
  315|      1|    fn test_get_default_database_path() {
  316|      1|        let default_path = ThingsConfig::get_default_database_path();
  317|       |
  318|       |        // Should be a valid path (may or may not exist)
  319|      1|        assert!(!default_path.to_string_lossy().is_empty());
  320|       |
  321|       |        // Should be a reasonable path (may or may not contain "Things3" depending on system)
  322|      1|        assert!(!default_path.to_string_lossy().is_empty());
  323|      1|    }
  324|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/database.rs:
    1|       |//! Database access layer for Things 3
    2|       |
    3|       |use crate::{
    4|       |    config::ThingsConfig,
    5|       |    error::Result,
    6|       |    models::{Area, Project, Task, TaskStatus, TaskType},
    7|       |};
    8|       |use chrono::{DateTime, NaiveDate, Utc};
    9|       |use rusqlite::Connection;
   10|       |use std::path::Path;
   11|       |use uuid::Uuid;
   12|       |
   13|       |/// Main database access struct
   14|       |pub struct ThingsDatabase {
   15|       |    conn: Connection,
   16|       |}
   17|       |
   18|       |impl ThingsDatabase {
   19|       |    /// Convert Things 3 type integer to `TaskType`
   20|    108|    fn convert_task_type(type_value: i32) -> TaskType {
   21|    108|        match type_value {
   22|      0|            1 => TaskType::Project,
   23|      0|            2 => TaskType::Heading,
   24|      0|            3 => TaskType::Area, // Checklist items are treated as areas in our model
   25|    108|            _ => TaskType::Todo,
   26|       |        }
   27|    108|    }
   28|       |
   29|       |    /// Convert Things 3 status integer to `TaskStatus`
   30|    108|    fn convert_task_status(status_value: i32) -> TaskStatus {
   31|    108|        match status_value {
   32|      0|            1 => TaskStatus::Completed,
   33|      0|            2 => TaskStatus::Canceled,
   34|      0|            3 => TaskStatus::Trashed,
   35|    108|            _ => TaskStatus::Incomplete,
   36|       |        }
   37|    108|    }
   38|       |
   39|       |    /// Convert Things 3 timestamp (REAL) to `DateTime<Utc>`
   40|    216|    fn convert_timestamp(timestamp: Option<f64>) -> DateTime<Utc> {
   41|    216|        timestamp.map_or_else(Utc::now, |ts| {
   42|       |            #[allow(clippy::cast_possible_truncation)]
   43|       |            {
   44|    216|                DateTime::from_timestamp(ts as i64, 0).unwrap_or_else(Utc::now)
   45|       |            }
   46|    216|        })
   47|    216|    }
   48|       |
   49|       |    /// Convert Things 3 date (INTEGER) to `NaiveDate`
   50|    216|    fn convert_date(date_value: Option<i64>) -> Option<NaiveDate> {
   51|    216|        date_value.and_then(|d| {
                                              ^56
   52|       |            // Things 3 stores dates as days since 2001-01-01
   53|     56|            let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1)?;
                                                                                     ^0
   54|       |            #[allow(clippy::cast_sign_loss)]
   55|       |            {
   56|     56|                base_date.checked_add_days(chrono::Days::new(d as u64))
   57|       |            }
   58|     56|        })
   59|    216|    }
   60|       |
   61|       |    /// Convert Things 3 UUID string to Uuid, handling None case
   62|       |    /// Things 3 uses a custom base64-like format, so we'll generate a UUID from the string
   63|    432|    fn convert_uuid(uuid_str: Option<String>) -> Option<Uuid> {
   64|    432|        uuid_str.map(|s| {
                                       ^108
   65|       |            // Try to parse as standard UUID first
   66|    108|            if let Ok(uuid) = Uuid::parse_str(&s) {
                                    ^75
   67|     75|                uuid
   68|       |            } else {
   69|       |                // For Things 3 format, generate a deterministic UUID from the string
   70|       |                use std::collections::hash_map::DefaultHasher;
   71|       |                use std::hash::{Hash, Hasher};
   72|     33|                let mut hasher = DefaultHasher::new();
   73|     33|                s.hash(&mut hasher);
   74|     33|                let hash = hasher.finish();
   75|       |                // Create a UUID from the hash
   76|     33|                Uuid::from_u128(u128::from(hash))
   77|       |            }
   78|    108|        })
   79|    432|    }
   80|       |    /// Create a new database connection
   81|       |    ///
   82|       |    /// # Errors
   83|       |    /// Returns `ThingsError::Database` if the database cannot be opened
   84|     69|    pub fn new<P: AsRef<Path>>(db_path: P) -> Result<Self> {
   85|     69|        let conn = Connection::open(db_path)?;
                          ^67                             ^2
   86|     67|        Ok(Self { conn })
   87|     69|    }
   88|       |
   89|       |    /// Create a new database connection using configuration
   90|       |    ///
   91|       |    /// # Errors
   92|       |    /// Returns `ThingsError::Database` if the database cannot be opened
   93|       |    /// Returns `ThingsError::Message` if the database path is not found and fallback fails
   94|      3|    pub fn with_config(config: &ThingsConfig) -> Result<Self> {
   95|      3|        let db_path = config.get_effective_database_path()?;
                          ^2                                            ^1
   96|      2|        Self::new(db_path)
   97|      3|    }
   98|       |
   99|       |    /// Get the default Things 3 database path
  100|       |    #[must_use]
  101|      6|    pub fn default_path() -> String {
  102|      6|        format!(
  103|      6|            "{}/Library/Group Containers/JLMPQHK86H.com.culturedcode.ThingsMac/ThingsData-0Z0Z2/Things Database.thingsdatabase/main.sqlite",
  104|      6|            std::env::var("HOME").unwrap_or_else(|_| "~".to_string())
                                                                   ^0  ^0
  105|       |        )
  106|      6|    }
  107|       |
  108|       |    /// Create with default database path
  109|       |    ///
  110|       |    /// # Errors
  111|       |    /// Returns `ThingsError::Database` if the database cannot be opened
  112|      1|    pub fn with_default_path() -> Result<Self> {
  113|      1|        Self::new(Self::default_path())
  114|      1|    }
  115|       |
  116|       |    /// Get tasks from inbox
  117|       |    ///
  118|       |    /// # Errors
  119|       |    /// Returns `ThingsError::Database` if the database query fails
  120|       |    ///
  121|       |    /// # Panics
  122|       |    /// Panics if UUID parsing fails (should not happen with valid database)
  123|     27|    pub fn get_inbox(&self, limit: Option<usize>) -> Result<Vec<Task>> {
  124|     27|        let mut stmt = self.conn.prepare(
  125|     27|            "SELECT uuid, title, type, status, notes, startDate, deadline, creationDate, userModificationDate, project, area, heading 
  126|     27|             FROM TMTask 
  127|     27|             WHERE status = 0 AND project IS NULL AND area IS NULL 
  128|     27|             ORDER BY creationDate DESC"
  129|      0|        )?;
  130|       |
  131|    108|        let rows = stmt.query_map([], |row| {
                          ^27    ^27  ^27       ^27
  132|       |            Ok(Task {
  133|    108|                uuid: Self::convert_uuid(Some(row.get("uuid")?)).unwrap_or_else(Uuid::new_v4),
                                                                           ^0
  134|    108|                title: row.get("title")?,
                                                     ^0
  135|    108|                task_type: Self::convert_task_type(row.get("type")?),
                                                                                ^0
  136|    108|                status: Self::convert_task_status(row.get("status")?),
                                                                                 ^0
  137|    108|                notes: row.get("notes")?,
                                                     ^0
  138|    108|                start_date: Self::convert_date(row.get("startDate")?),
                                                                                 ^0
  139|    108|                deadline: Self::convert_date(row.get("deadline")?),
                                                                              ^0
  140|    108|                created: Self::convert_timestamp(row.get("creationDate")?),
                                                                                      ^0
  141|    108|                modified: Self::convert_timestamp(row.get("userModificationDate")?),
                                                                                               ^0
  142|    108|                project_uuid: Self::convert_uuid(row.get("project")?),
                                                                                 ^0
  143|    108|                area_uuid: Self::convert_uuid(row.get("area")?),
                                                                           ^0
  144|    108|                parent_uuid: Self::convert_uuid(row.get("heading")?),
                                                                                ^0
  145|    108|                tags: vec![],     // TODO: Load tags separately
  146|    108|                children: vec![], // TODO: Load children separately
  147|       |            })
  148|    108|        })?;
                        ^0
  149|       |
  150|     27|        let mut tasks: Vec<Task> = rows.collect::<std::result::Result<Vec<_>, _>>()?;
                                                                                                 ^0
  151|       |
  152|     27|        if let Some(limit) = limit {
                                  ^8
  153|      8|            tasks.truncate(limit);
  154|     19|        }
  155|       |
  156|     27|        Ok(tasks)
  157|     27|    }
  158|       |
  159|       |    /// Get today's tasks
  160|       |    ///
  161|       |    /// # Errors
  162|       |    /// Returns `ThingsError::Database` if the database query fails
  163|       |    ///
  164|       |    /// # Panics
  165|       |    /// Panics if UUID parsing fails (should not happen with valid database)
  166|     11|    pub fn get_today(&self, limit: Option<usize>) -> Result<Vec<Task>> {
  167|     11|        let today = chrono::Utc::now().date_naive();
  168|       |        // Convert today to days since 2001-01-01 (Things 3 format)
  169|     11|        let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  170|     11|        let days_since_2001 = today.signed_duration_since(base_date).num_days();
  171|       |
  172|     11|        let mut stmt = self.conn.prepare(
  173|     11|            "SELECT uuid, title, type, status, notes, startDate, deadline, creationDate, userModificationDate, project, area, heading 
  174|     11|             FROM TMTask 
  175|     11|             WHERE status = 0 AND startDate = ? 
  176|     11|             ORDER BY creationDate DESC"
  177|      0|        )?;
  178|       |
  179|     11|        let rows = stmt.query_map([days_since_2001], |row| {
                                                                         ^10
  180|       |            Ok(Task {
  181|     10|                uuid: Uuid::parse_str(&row.get::<_, String>("uuid")?)
                                                                                 ^0
  182|     10|                    .unwrap_or_else(|_| Uuid::new_v4()),
                                                      ^0
  183|     10|                title: row.get("title")?,
                                                     ^0
  184|     10|                task_type: match row.get::<_, i32>("type")? {
                                                                        ^0
  185|      0|                    1 => TaskType::Project,
  186|      0|                    2 => TaskType::Heading,
  187|      0|                    3 => TaskType::Area,
  188|     10|                    _ => TaskType::Todo,
  189|       |                },
  190|     10|                status: match row.get::<_, i32>("status")? {
                                                                       ^0
  191|      0|                    1 => TaskStatus::Completed,
  192|      0|                    2 => TaskStatus::Canceled,
  193|      0|                    3 => TaskStatus::Trashed,
  194|     10|                    _ => TaskStatus::Incomplete,
  195|       |                },
  196|     10|                notes: row.get("notes")?,
                                                     ^0
  197|     10|                start_date: row.get::<_, Option<i32>>("startDate")?.and_then(|days| {
                                                                                ^0
  198|       |                    // Convert from days since 2001-01-01 to NaiveDate
  199|     10|                    let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  200|     10|                    base_date.checked_add_days(chrono::Days::new(days as u64))
  201|     10|                }),
  202|     10|                deadline: row.get::<_, Option<i32>>("deadline")?.and_then(|days| {
                                                                             ^0                ^0
  203|       |                    // Convert from days since 2001-01-01 to NaiveDate
  204|      0|                    let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  205|      0|                    base_date.checked_add_days(chrono::Days::new(days as u64))
  206|      0|                }),
  207|       |                created: {
  208|     10|                    let timestamp = row.get::<_, f64>("creationDate")?;
                                                                                   ^0
  209|       |                    // Convert from Core Data timestamp (seconds since 2001-01-01) to DateTime<Utc>
  210|     10|                    let base_date = chrono::DateTime::parse_from_rfc3339("2001-01-01T00:00:00Z")
  211|     10|                        .unwrap()
  212|     10|                        .with_timezone(&chrono::Utc);
  213|     10|                    base_date + chrono::Duration::seconds(timestamp as i64)
  214|       |                },
  215|       |                modified: {
  216|     10|                    let timestamp = row.get::<_, f64>("userModificationDate")?;
                                                                                           ^0
  217|       |                    // Convert from Core Data timestamp (seconds since 2001-01-01) to DateTime<Utc>
  218|     10|                    let base_date = chrono::DateTime::parse_from_rfc3339("2001-01-01T00:00:00Z")
  219|     10|                        .unwrap()
  220|     10|                        .with_timezone(&chrono::Utc);
  221|     10|                    base_date + chrono::Duration::seconds(timestamp as i64)
  222|       |                },
  223|     10|                project_uuid: row
  224|     10|                    .get::<_, Option<String>>("project")?
                                                                      ^0
  225|     10|                    .and_then(|s| Uuid::parse_str(&s).ok()),
                                                ^0              ^0  ^0
  226|     10|                area_uuid: row
  227|     10|                    .get::<_, Option<String>>("area")?
                                                                   ^0
  228|     10|                    .and_then(|s| Uuid::parse_str(&s).ok()),
                                                ^0              ^0  ^0
  229|     10|                parent_uuid: row
  230|     10|                    .get::<_, Option<String>>("heading")?
                                                                      ^0
  231|     10|                    .and_then(|s| Uuid::parse_str(&s).ok()),
                                                ^0              ^0  ^0
  232|     10|                tags: vec![],     // TODO: Load tags separately
  233|     10|                children: vec![], // TODO: Load children separately
  234|       |            })
  235|     10|        })?;
                        ^0
  236|       |
  237|     11|        let mut tasks: Vec<Task> = rows.collect::<std::result::Result<Vec<_>, _>>()?;
                                                                                                 ^0
  238|       |
  239|     11|        if let Some(limit) = limit {
                                  ^4
  240|      4|            tasks.truncate(limit);
  241|      7|        }
  242|       |
  243|     11|        Ok(tasks)
  244|     11|    }
  245|       |
  246|       |    /// Get all projects
  247|       |    ///
  248|       |    /// # Errors
  249|       |    /// Returns `ThingsError::Database` if the database query fails
  250|      9|    pub fn get_projects(&self, area_uuid: Option<Uuid>) -> Result<Vec<Project>> {
  251|      9|        let query = if area_uuid.is_some() {
  252|      0|            "SELECT uuid, title, notes, startDate, deadline, creationDate, userModificationDate, area, status 
  253|      0|             FROM TMTask 
  254|      0|             WHERE type = 1 AND area = ? 
  255|      0|             ORDER BY creationDate DESC"
  256|       |        } else {
  257|      9|            "SELECT uuid, title, notes, startDate, deadline, creationDate, userModificationDate, area, status 
  258|      9|             FROM TMTask 
  259|      9|             WHERE type = 1 
  260|      9|             ORDER BY creationDate DESC"
  261|       |        };
  262|       |
  263|      9|        let mut stmt = self.conn.prepare(query)?;
                                                             ^0
  264|      9|        let rows = if let Some(area_uuid) = area_uuid {
                                             ^0
  265|      0|            stmt.query_map([area_uuid.to_string()], Self::map_project_row)?
  266|       |        } else {
  267|      9|            stmt.query_map([], Self::map_project_row)?
                                                                   ^0
  268|       |        };
  269|       |
  270|      9|        let projects: Vec<Project> = rows.collect::<std::result::Result<Vec<_>, _>>()?;
                                                                                                   ^0
  271|      9|        Ok(projects)
  272|      9|    }
  273|       |
  274|       |    /// Get all areas
  275|       |    ///
  276|       |    /// # Errors
  277|       |    /// Returns `ThingsError::Database` if the database query fails
  278|       |    ///
  279|       |    /// # Panics
  280|       |    /// Panics if UUID parsing fails (should not happen with valid database)
  281|      7|    pub fn get_areas(&self) -> Result<Vec<Area>> {
  282|      7|        let mut stmt = self.conn.prepare(
  283|      7|            "SELECT uuid, title, visible, \"index\" 
  284|      7|             FROM TMArea 
  285|      7|             WHERE visible IS NULL OR visible = 1 
  286|      7|             ORDER BY \"index\"",
  287|      0|        )?;
  288|       |
  289|     17|        let rows = stmt.query_map([], |row| {
                          ^7     ^7   ^7        ^7
  290|       |            Ok(Area {
  291|     17|                uuid: Uuid::parse_str(&row.get::<_, String>("uuid")?)
                                                                                 ^0
  292|     17|                    .unwrap_or_else(|_| Uuid::new_v4()),
                                                      ^8
  293|     17|                title: row.get("title")?,
                                                     ^0
  294|     17|                notes: None,                  // TMArea doesn't have notes field
  295|     17|                created: chrono::Utc::now(),  // TMArea doesn't track creation date
  296|     17|                modified: chrono::Utc::now(), // TMArea doesn't track modification date
  297|     17|                tags: vec![],                 // TODO: Load tags separately
  298|     17|                projects: vec![],             // TODO: Load projects separately
  299|       |            })
  300|     17|        })?;
                        ^0
  301|       |
  302|      7|        let areas: Vec<Area> = rows.collect::<std::result::Result<Vec<_>, _>>()?;
                                                                                             ^0
  303|      7|        Ok(areas)
  304|      7|    }
  305|       |
  306|       |    /// Search tasks
  307|       |    ///
  308|       |    /// # Errors
  309|       |    /// Returns `ThingsError::Database` if the database query fails
  310|       |    ///
  311|       |    /// # Panics
  312|       |    /// Panics if UUID parsing fails (should not happen with valid database)
  313|     10|    pub fn search_tasks(&self, query: &str, limit: Option<usize>) -> Result<Vec<Task>> {
  314|     10|        let search_pattern = format!("%{query}%");
  315|     10|        let mut stmt = self.conn.prepare(
  316|     10|            "SELECT uuid, title, type, status, notes, startDate, deadline, creationDate, userModificationDate, project, area, heading 
  317|     10|             FROM TMTask 
  318|     10|             WHERE (title LIKE ? OR notes LIKE ?) AND status = 0
  319|     10|             ORDER BY creationDate DESC"
  320|      0|        )?;
  321|       |
  322|     31|        let rows = stmt.query_map([&search_pattern, &search_pattern], |row| {
                          ^10    ^10  ^10       ^10
  323|     31|            let uuid_str = row.get::<_, String>("uuid")?;
                                                                     ^0
  324|     31|            let uuid = Uuid::parse_str(&uuid_str).unwrap_or_else(|_| {
                                                                                   ^0
  325|       |                // Generate a new UUID if parsing fails
  326|      0|                Uuid::new_v4()
  327|      0|            });
  328|       |            Ok(Task {
  329|     31|                uuid,
  330|     31|                title: row.get("title")?,
                                                     ^0
  331|     31|                task_type: match row.get::<_, i32>("type")? {
                                                                        ^0
  332|      8|                    1 => TaskType::Project,
  333|      0|                    2 => TaskType::Heading,
  334|      0|                    3 => TaskType::Area,
  335|     23|                    _ => TaskType::Todo,
  336|       |                },
  337|     31|                status: match row.get::<_, i32>("status")? {
                                                                       ^0
  338|      0|                    1 => TaskStatus::Completed,
  339|      0|                    2 => TaskStatus::Canceled,
  340|      0|                    3 => TaskStatus::Trashed,
  341|     31|                    _ => TaskStatus::Incomplete,
  342|       |                },
  343|     31|                notes: row.get("notes")?,
                                                     ^0
  344|     31|                start_date: row.get::<_, Option<i32>>("startDate")?.and_then(|days| {
                                                                                ^0                ^17
  345|       |                    // Convert from days since 2001-01-01 to NaiveDate
  346|     17|                    let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  347|     17|                    base_date.checked_add_days(chrono::Days::new(days as u64))
  348|     17|                }),
  349|     31|                deadline: row.get::<_, Option<i32>>("deadline")?.and_then(|days| {
                                                                             ^0                ^10
  350|       |                    // Convert from days since 2001-01-01 to NaiveDate
  351|     10|                    let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  352|     10|                    base_date.checked_add_days(chrono::Days::new(days as u64))
  353|     10|                }),
  354|       |                created: {
  355|     31|                    let timestamp = row.get::<_, f64>("creationDate")?;
                                                                                   ^0
  356|       |                    // Convert from Core Data timestamp (seconds since 2001-01-01) to DateTime<Utc>
  357|     31|                    let base_date = chrono::DateTime::parse_from_rfc3339("2001-01-01T00:00:00Z")
  358|     31|                        .unwrap()
  359|     31|                        .with_timezone(&chrono::Utc);
  360|     31|                    base_date + chrono::Duration::seconds(timestamp as i64)
  361|       |                },
  362|       |                modified: {
  363|     31|                    let timestamp = row.get::<_, f64>("userModificationDate")?;
                                                                                           ^0
  364|       |                    // Convert from Core Data timestamp (seconds since 2001-01-01) to DateTime<Utc>
  365|     31|                    let base_date = chrono::DateTime::parse_from_rfc3339("2001-01-01T00:00:00Z")
  366|     31|                        .unwrap()
  367|     31|                        .with_timezone(&chrono::Utc);
  368|     31|                    base_date + chrono::Duration::seconds(timestamp as i64)
  369|       |                },
  370|     31|                project_uuid: row
  371|     31|                    .get::<_, Option<String>>("project")?
                                                                      ^0
  372|     31|                    .and_then(|s| Uuid::parse_str(&s).ok()),
                                                ^0              ^0  ^0
  373|     31|                area_uuid: row
  374|     31|                    .get::<_, Option<String>>("area")?
                                                                   ^0
  375|     31|                    .and_then(|s| Uuid::parse_str(&s).ok()),
                                                ^8              ^8  ^8
  376|     31|                parent_uuid: row
  377|     31|                    .get::<_, Option<String>>("heading")?
                                                                      ^0
  378|     31|                    .and_then(|s| Uuid::parse_str(&s).ok()),
                                                ^0              ^0  ^0
  379|     31|                tags: vec![],     // TODO: Load tags separately
  380|     31|                children: vec![], // TODO: Load children separately
  381|       |            })
  382|     31|        })?;
                        ^0
  383|       |
  384|     10|        let mut tasks: Vec<Task> = rows.collect::<std::result::Result<Vec<_>, _>>()?;
                                                                                                 ^0
  385|       |
  386|     10|        if let Some(limit) = limit {
                                  ^4
  387|      4|            tasks.truncate(limit);
  388|      6|        }
  389|       |
  390|     10|        Ok(tasks)
  391|     10|    }
  392|       |
  393|       |    /// Helper method to map a database row to a Project
  394|      8|    fn map_project_row(row: &rusqlite::Row) -> rusqlite::Result<Project> {
  395|       |        Ok(Project {
  396|      8|            uuid: Uuid::parse_str(&row.get::<_, String>("uuid")?)
                                                                             ^0
  397|      8|                .unwrap_or_else(|_| Uuid::new_v4()),
                                                  ^0
  398|      8|            title: row.get("title")?,
                                                 ^0
  399|      8|            notes: row.get("notes")?,
                                                 ^0
  400|      8|            start_date: row.get::<_, Option<i32>>("startDate")?.and_then(|days| {
                                                                            ^0
  401|       |                // Convert from days since 2001-01-01 to NaiveDate
  402|      8|                let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  403|      8|                base_date.checked_add_days(chrono::Days::new(days as u64))
  404|      8|            }),
  405|      8|            deadline: row.get::<_, Option<i32>>("deadline")?.and_then(|days| {
                                                                         ^0                ^4
  406|       |                // Convert from days since 2001-01-01 to NaiveDate
  407|      4|                let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  408|      4|                base_date.checked_add_days(chrono::Days::new(days as u64))
  409|      4|            }),
  410|       |            created: {
  411|      8|                let timestamp = row.get::<_, f64>("creationDate")?;
                                                                               ^0
  412|       |                // Convert from Core Data timestamp (seconds since 2001-01-01) to DateTime<Utc>
  413|      8|                let base_date = chrono::DateTime::parse_from_rfc3339("2001-01-01T00:00:00Z")
  414|      8|                    .unwrap()
  415|      8|                    .with_timezone(&chrono::Utc);
  416|      8|                base_date + chrono::Duration::seconds(timestamp as i64)
  417|       |            },
  418|       |            modified: {
  419|      8|                let timestamp = row.get::<_, f64>("userModificationDate")?;
                                                                                       ^0
  420|       |                // Convert from Core Data timestamp (seconds since 2001-01-01) to DateTime<Utc>
  421|      8|                let base_date = chrono::DateTime::parse_from_rfc3339("2001-01-01T00:00:00Z")
  422|      8|                    .unwrap()
  423|      8|                    .with_timezone(&chrono::Utc);
  424|      8|                base_date + chrono::Duration::seconds(timestamp as i64)
  425|       |            },
  426|      8|            area_uuid: row
  427|      8|                .get::<_, Option<String>>("area")?
                                                               ^0
  428|      8|                .and_then(|s| Uuid::parse_str(&s).ok()),
  429|      8|            tags: vec![], // TODO: Load tags separately
  430|      8|            status: match row.get::<_, i32>("status")? {
                                                                   ^0
  431|      0|                1 => TaskStatus::Completed,
  432|      0|                2 => TaskStatus::Canceled,
  433|      0|                3 => TaskStatus::Trashed,
  434|      8|                _ => TaskStatus::Incomplete,
  435|       |            },
  436|      8|            tasks: vec![], // TODO: Load tasks separately
  437|       |        })
  438|      8|    }
  439|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/error.rs:
    1|       |//! Error types for the Things Core library
    2|       |
    3|       |use thiserror::Error;
    4|       |
    5|       |/// Result type alias for Things operations
    6|       |pub type Result<T> = std::result::Result<T, ThingsError>;
    7|       |
    8|       |/// Main error type for Things operations
    9|       |#[derive(Error, Debug)]
   10|       |pub enum ThingsError {
   11|       |    #[error("Database error: {0}")]
   12|       |    Database(#[from] rusqlite::Error),
   13|       |
   14|       |    #[error("Serialization error: {0}")]
   15|       |    Serialization(#[from] serde_json::Error),
   16|       |
   17|       |    #[error("IO error: {0}")]
   18|       |    Io(#[from] std::io::Error),
   19|       |
   20|       |    #[error("Database not found: {path}")]
   21|       |    DatabaseNotFound { path: String },
   22|       |
   23|       |    #[error("Invalid UUID: {uuid}")]
   24|       |    InvalidUuid { uuid: String },
   25|       |
   26|       |    #[error("Invalid date: {date}")]
   27|       |    InvalidDate { date: String },
   28|       |
   29|       |    #[error("Task not found: {uuid}")]
   30|       |    TaskNotFound { uuid: String },
   31|       |
   32|       |    #[error("Project not found: {uuid}")]
   33|       |    ProjectNotFound { uuid: String },
   34|       |
   35|       |    #[error("Area not found: {uuid}")]
   36|       |    AreaNotFound { uuid: String },
   37|       |
   38|       |    #[error("Validation error: {message}")]
   39|       |    Validation { message: String },
   40|       |
   41|       |    #[error("Configuration error: {message}")]
   42|       |    Configuration { message: String },
   43|       |
   44|       |    #[error("Unknown error: {message}")]
   45|       |    Unknown { message: String },
   46|       |}
   47|       |
   48|       |impl ThingsError {
   49|       |    /// Create a validation error
   50|      4|    pub fn validation(message: impl Into<String>) -> Self {
   51|      4|        Self::Validation {
   52|      4|            message: message.into(),
   53|      4|        }
   54|      4|    }
   55|       |
   56|       |    /// Create a configuration error
   57|      6|    pub fn configuration(message: impl Into<String>) -> Self {
   58|      6|        Self::Configuration {
   59|      6|            message: message.into(),
   60|      6|        }
   61|      6|    }
   62|       |
   63|       |    /// Create an unknown error
   64|      2|    pub fn unknown(message: impl Into<String>) -> Self {
   65|      2|        Self::Unknown {
   66|      2|            message: message.into(),
   67|      2|        }
   68|      2|    }
   69|       |}
   70|       |
   71|       |#[cfg(test)]
   72|       |mod tests {
   73|       |    use super::*;
   74|       |    use std::io;
   75|       |
   76|       |    #[test]
   77|      1|    fn test_database_error_from_rusqlite() {
   78|      1|        let sqlite_error = rusqlite::Error::SqliteFailure(
   79|      1|            rusqlite::ffi::Error::new(1),
   80|      1|            Some("test error".to_string()),
   81|      1|        );
   82|      1|        let things_error: ThingsError = sqlite_error.into();
   83|       |
   84|      1|        match things_error {
   85|      1|            ThingsError::Database(_) => (),
   86|      0|            _ => panic!("Expected Database error"),
   87|       |        }
   88|      1|    }
   89|       |
   90|       |    #[test]
   91|      1|    fn test_serialization_error_from_serde() {
   92|      1|        let json_error = serde_json::from_str::<serde_json::Value>("invalid json").unwrap_err();
   93|      1|        let things_error: ThingsError = json_error.into();
   94|       |
   95|      1|        match things_error {
   96|      1|            ThingsError::Serialization(_) => (),
   97|      0|            _ => panic!("Expected Serialization error"),
   98|       |        }
   99|      1|    }
  100|       |
  101|       |    #[test]
  102|      1|    fn test_io_error_from_std() {
  103|      1|        let io_error = io::Error::new(io::ErrorKind::NotFound, "file not found");
  104|      1|        let things_error: ThingsError = io_error.into();
  105|       |
  106|      1|        match things_error {
  107|      1|            ThingsError::Io(_) => (),
  108|      0|            _ => panic!("Expected Io error"),
  109|       |        }
  110|      1|    }
  111|       |
  112|       |    #[test]
  113|      1|    fn test_database_not_found_error() {
  114|      1|        let error = ThingsError::DatabaseNotFound {
  115|      1|            path: "/path/to/db".to_string(),
  116|      1|        };
  117|       |
  118|      1|        assert!(error.to_string().contains("Database not found"));
  119|      1|        assert!(error.to_string().contains("/path/to/db"));
  120|      1|    }
  121|       |
  122|       |    #[test]
  123|      1|    fn test_invalid_uuid_error() {
  124|      1|        let error = ThingsError::InvalidUuid {
  125|      1|            uuid: "invalid-uuid".to_string(),
  126|      1|        };
  127|       |
  128|      1|        assert!(error.to_string().contains("Invalid UUID"));
  129|      1|        assert!(error.to_string().contains("invalid-uuid"));
  130|      1|    }
  131|       |
  132|       |    #[test]
  133|      1|    fn test_invalid_date_error() {
  134|      1|        let error = ThingsError::InvalidDate {
  135|      1|            date: "2023-13-45".to_string(),
  136|      1|        };
  137|       |
  138|      1|        assert!(error.to_string().contains("Invalid date"));
  139|      1|        assert!(error.to_string().contains("2023-13-45"));
  140|      1|    }
  141|       |
  142|       |    #[test]
  143|      1|    fn test_task_not_found_error() {
  144|      1|        let error = ThingsError::TaskNotFound {
  145|      1|            uuid: "task-uuid-123".to_string(),
  146|      1|        };
  147|       |
  148|      1|        assert!(error.to_string().contains("Task not found"));
  149|      1|        assert!(error.to_string().contains("task-uuid-123"));
  150|      1|    }
  151|       |
  152|       |    #[test]
  153|      1|    fn test_project_not_found_error() {
  154|      1|        let error = ThingsError::ProjectNotFound {
  155|      1|            uuid: "project-uuid-456".to_string(),
  156|      1|        };
  157|       |
  158|      1|        assert!(error.to_string().contains("Project not found"));
  159|      1|        assert!(error.to_string().contains("project-uuid-456"));
  160|      1|    }
  161|       |
  162|       |    #[test]
  163|      1|    fn test_area_not_found_error() {
  164|      1|        let error = ThingsError::AreaNotFound {
  165|      1|            uuid: "area-uuid-789".to_string(),
  166|      1|        };
  167|       |
  168|      1|        assert!(error.to_string().contains("Area not found"));
  169|      1|        assert!(error.to_string().contains("area-uuid-789"));
  170|      1|    }
  171|       |
  172|       |    #[test]
  173|      1|    fn test_validation_error() {
  174|      1|        let error = ThingsError::Validation {
  175|      1|            message: "Invalid input data".to_string(),
  176|      1|        };
  177|       |
  178|      1|        assert!(error.to_string().contains("Validation error"));
  179|      1|        assert!(error.to_string().contains("Invalid input data"));
  180|      1|    }
  181|       |
  182|       |    #[test]
  183|      1|    fn test_configuration_error() {
  184|      1|        let error = ThingsError::Configuration {
  185|      1|            message: "Missing required config".to_string(),
  186|      1|        };
  187|       |
  188|      1|        assert!(error.to_string().contains("Configuration error"));
  189|      1|        assert!(error.to_string().contains("Missing required config"));
  190|      1|    }
  191|       |
  192|       |    #[test]
  193|      1|    fn test_unknown_error() {
  194|      1|        let error = ThingsError::Unknown {
  195|      1|            message: "Something went wrong".to_string(),
  196|      1|        };
  197|       |
  198|      1|        assert!(error.to_string().contains("Unknown error"));
  199|      1|        assert!(error.to_string().contains("Something went wrong"));
  200|      1|    }
  201|       |
  202|       |    #[test]
  203|      1|    fn test_validation_helper() {
  204|      1|        let error = ThingsError::validation("Test validation message");
  205|       |
  206|      1|        match error {
  207|      1|            ThingsError::Validation { message } => {
  208|      1|                assert_eq!(message, "Test validation message");
  209|       |            }
  210|      0|            _ => panic!("Expected Validation error"),
  211|       |        }
  212|      1|    }
  213|       |
  214|       |    #[test]
  215|      1|    fn test_validation_helper_with_string() {
  216|      1|        let message = "Test validation message".to_string();
  217|      1|        let error = ThingsError::validation(message);
  218|       |
  219|      1|        match error {
  220|      1|            ThingsError::Validation { message } => {
  221|      1|                assert_eq!(message, "Test validation message");
  222|       |            }
  223|      0|            _ => panic!("Expected Validation error"),
  224|       |        }
  225|      1|    }
  226|       |
  227|       |    #[test]
  228|      1|    fn test_configuration_helper() {
  229|      1|        let error = ThingsError::configuration("Test config message");
  230|       |
  231|      1|        match error {
  232|      1|            ThingsError::Configuration { message } => {
  233|      1|                assert_eq!(message, "Test config message");
  234|       |            }
  235|      0|            _ => panic!("Expected Configuration error"),
  236|       |        }
  237|      1|    }
  238|       |
  239|       |    #[test]
  240|      1|    fn test_configuration_helper_with_string() {
  241|      1|        let message = "Test config message".to_string();
  242|      1|        let error = ThingsError::configuration(message);
  243|       |
  244|      1|        match error {
  245|      1|            ThingsError::Configuration { message } => {
  246|      1|                assert_eq!(message, "Test config message");
  247|       |            }
  248|      0|            _ => panic!("Expected Configuration error"),
  249|       |        }
  250|      1|    }
  251|       |
  252|       |    #[test]
  253|      1|    fn test_unknown_helper() {
  254|      1|        let error = ThingsError::unknown("Test unknown message");
  255|       |
  256|      1|        match error {
  257|      1|            ThingsError::Unknown { message } => {
  258|      1|                assert_eq!(message, "Test unknown message");
  259|       |            }
  260|      0|            _ => panic!("Expected Unknown error"),
  261|       |        }
  262|      1|    }
  263|       |
  264|       |    #[test]
  265|      1|    fn test_unknown_helper_with_string() {
  266|      1|        let message = "Test unknown message".to_string();
  267|      1|        let error = ThingsError::unknown(message);
  268|       |
  269|      1|        match error {
  270|      1|            ThingsError::Unknown { message } => {
  271|      1|                assert_eq!(message, "Test unknown message");
  272|       |            }
  273|      0|            _ => panic!("Expected Unknown error"),
  274|       |        }
  275|      1|    }
  276|       |
  277|       |    #[test]
  278|      1|    fn test_error_display_formatting() {
  279|      1|        let errors = vec![
  280|      1|            ThingsError::DatabaseNotFound {
  281|      1|                path: "test.db".to_string(),
  282|      1|            },
  283|      1|            ThingsError::InvalidUuid {
  284|      1|                uuid: "bad-uuid".to_string(),
  285|      1|            },
  286|      1|            ThingsError::InvalidDate {
  287|      1|                date: "bad-date".to_string(),
  288|      1|            },
  289|      1|            ThingsError::TaskNotFound {
  290|      1|                uuid: "task-123".to_string(),
  291|      1|            },
  292|      1|            ThingsError::ProjectNotFound {
  293|      1|                uuid: "project-456".to_string(),
  294|      1|            },
  295|      1|            ThingsError::AreaNotFound {
  296|      1|                uuid: "area-789".to_string(),
  297|      1|            },
  298|      1|            ThingsError::Validation {
  299|      1|                message: "validation failed".to_string(),
  300|      1|            },
  301|      1|            ThingsError::Configuration {
  302|      1|                message: "config error".to_string(),
  303|      1|            },
  304|      1|            ThingsError::Unknown {
  305|      1|                message: "unknown error".to_string(),
  306|      1|            },
  307|       |        ];
  308|       |
  309|     10|        for error in errors {
                          ^9
  310|      9|            let error_string = error.to_string();
  311|      9|            assert!(!error_string.is_empty());
  312|      9|            assert!(error_string.len() > 10); // Should have meaningful content
  313|       |        }
  314|      1|    }
  315|       |
  316|       |    #[test]
  317|      1|    fn test_error_debug_formatting() {
  318|      1|        let error = ThingsError::Validation {
  319|      1|            message: "test message".to_string(),
  320|      1|        };
  321|       |
  322|      1|        let debug_string = format!("{:?}", error);
  323|      1|        assert!(debug_string.contains("Validation"));
  324|      1|        assert!(debug_string.contains("test message"));
  325|      1|    }
  326|       |
  327|       |    #[test]
  328|      1|    fn test_result_type_alias() {
  329|       |        // Test that the Result type alias works correctly
  330|      1|        fn returns_result() -> Result<String> {
  331|      1|            Ok("success".to_string())
  332|      1|        }
  333|       |
  334|      2|        fn returns_error() -> Result<String> {
  335|      2|            Err(ThingsError::validation("test error"))
  336|      2|        }
  337|       |
  338|      1|        assert!(returns_result().is_ok());
  339|      1|        assert!(returns_error().is_err());
  340|       |
  341|      1|        match returns_error() {
  342|      1|            Err(ThingsError::Validation { message }) => {
  343|      1|                assert_eq!(message, "test error");
  344|       |            }
  345|      0|            _ => panic!("Expected Validation error"),
  346|       |        }
  347|      1|    }
  348|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/export.rs:
    1|       |//! Data export functionality for Things 3 data
    2|       |
    3|       |use crate::models::{Area, Project, Task, TaskStatus, TaskType};
    4|       |use anyhow::Result;
    5|       |use chrono::{DateTime, Utc};
    6|       |use serde::{Deserialize, Serialize};
    7|       |use std::collections::HashMap;
    8|       |
    9|       |/// Export format enumeration
   10|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   11|       |pub enum ExportFormat {
   12|       |    Json,
   13|       |    Csv,
   14|       |    Opml,
   15|       |    Markdown,
   16|       |}
   17|       |
   18|       |impl std::str::FromStr for ExportFormat {
   19|       |    type Err = anyhow::Error;
   20|       |
   21|     12|    fn from_str(s: &str) -> Result<Self> {
   22|     12|        match s.to_lowercase().as_str() {
   23|     12|            "json" => Ok(ExportFormat::Json),
                                    ^2
   24|     10|            "csv" => Ok(ExportFormat::Csv),
                                   ^2
   25|      8|            "opml" => Ok(ExportFormat::Opml),
                                    ^2
   26|      6|            "markdown" | "md" => Ok(ExportFormat::Markdown),
                                       ^4      ^4
   27|      2|            _ => Err(anyhow::anyhow!("Unsupported export format: {}", s)),
   28|       |        }
   29|     12|    }
   30|       |}
   31|       |
   32|       |/// Export data structure
   33|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   34|       |pub struct ExportData {
   35|       |    pub tasks: Vec<Task>,
   36|       |    pub projects: Vec<Project>,
   37|       |    pub areas: Vec<Area>,
   38|       |    pub exported_at: DateTime<Utc>,
   39|       |    pub total_items: usize,
   40|       |}
   41|       |
   42|       |impl ExportData {
   43|     11|    pub fn new(tasks: Vec<Task>, projects: Vec<Project>, areas: Vec<Area>) -> Self {
   44|     11|        let total_items = tasks.len() + projects.len() + areas.len();
   45|     11|        Self {
   46|     11|            tasks,
   47|     11|            projects,
   48|     11|            areas,
   49|     11|            exported_at: Utc::now(),
   50|     11|            total_items,
   51|     11|        }
   52|     11|    }
   53|       |}
   54|       |
   55|       |/// Export configuration
   56|       |#[derive(Debug, Clone)]
   57|       |pub struct ExportConfig {
   58|       |    pub include_metadata: bool,
   59|       |    pub include_notes: bool,
   60|       |    pub include_tags: bool,
   61|       |    pub date_format: String,
   62|       |    pub timezone: String,
   63|       |}
   64|       |
   65|       |impl Default for ExportConfig {
   66|     50|    fn default() -> Self {
   67|     50|        Self {
   68|     50|            include_metadata: true,
   69|     50|            include_notes: true,
   70|     50|            include_tags: true,
   71|     50|            date_format: "%Y-%m-%d %H:%M:%S".to_string(),
   72|     50|            timezone: "UTC".to_string(),
   73|     50|        }
   74|     50|    }
   75|       |}
   76|       |
   77|       |/// Data exporter for Things 3 data
   78|       |pub struct DataExporter {
   79|       |    #[allow(dead_code)]
   80|       |    config: ExportConfig,
   81|       |}
   82|       |
   83|       |impl DataExporter {
   84|     48|    pub fn new(config: ExportConfig) -> Self {
   85|     48|        Self { config }
   86|     48|    }
   87|       |
   88|     47|    pub fn new_default() -> Self {
   89|     47|        Self::new(ExportConfig::default())
   90|     47|    }
   91|       |
   92|       |    /// Export data in the specified format
   93|      8|    pub fn export(&self, data: &ExportData, format: ExportFormat) -> Result<String> {
   94|      8|        match format {
   95|      2|            ExportFormat::Json => self.export_json(data),
   96|      2|            ExportFormat::Csv => self.export_csv(data),
   97|      2|            ExportFormat::Opml => self.export_opml(data),
   98|      2|            ExportFormat::Markdown => self.export_markdown(data),
   99|       |        }
  100|      8|    }
  101|       |
  102|       |    /// Export as JSON
  103|      2|    fn export_json(&self, data: &ExportData) -> Result<String> {
  104|      2|        Ok(serde_json::to_string_pretty(data)?)
                                                           ^0
  105|      2|    }
  106|       |
  107|       |    /// Export as CSV
  108|      2|    fn export_csv(&self, data: &ExportData) -> Result<String> {
  109|      2|        let mut csv = String::new();
  110|       |
  111|       |        // Export tasks
  112|      2|        if !data.tasks.is_empty() {
  113|      1|            csv.push_str("Type,Title,Status,Notes,Start Date,Deadline,Created,Modified,Project,Area,Parent\n");
  114|      3|            for task in &data.tasks {
                              ^2
  115|      2|                csv.push_str(&format!(
  116|      2|                    "{},{},{},{},{},{},{},{},{},{},{}\n",
  117|      2|                    format_task_type_csv(&task.task_type),
  118|      2|                    escape_csv(&task.title),
  119|      2|                    format_task_status_csv(&task.status),
  120|      2|                    escape_csv(task.notes.as_deref().unwrap_or("")),
  121|      2|                    format_date_csv(task.start_date),
  122|      2|                    format_date_csv(task.deadline),
  123|      2|                    format_datetime_csv(task.created),
  124|      2|                    format_datetime_csv(task.modified),
  125|      2|                    task.project_uuid.map(|u| u.to_string()).unwrap_or_default(),
                                                            ^0^0
  126|      2|                    task.area_uuid.map(|u| u.to_string()).unwrap_or_default(),
                                                         ^0^0
  127|      2|                    task.parent_uuid.map(|u| u.to_string()).unwrap_or_default(),
                                                           ^0^0
  128|       |                ));
  129|       |            }
  130|      1|        }
  131|       |
  132|       |        // Export projects
  133|      2|        if !data.projects.is_empty() {
  134|      1|            csv.push_str("\n\nProjects\n");
  135|      1|            csv.push_str("Title,Status,Notes,Start Date,Deadline,Created,Modified,Area\n");
  136|      2|            for project in &data.projects {
                              ^1
  137|      1|                csv.push_str(&format!(
  138|      1|                    "{},{},{},{},{},{},{},{}\n",
  139|      1|                    escape_csv(&project.title),
  140|      1|                    format_task_status_csv(&project.status),
  141|      1|                    escape_csv(project.notes.as_deref().unwrap_or("")),
  142|      1|                    format_date_csv(project.start_date),
  143|      1|                    format_date_csv(project.deadline),
  144|      1|                    format_datetime_csv(project.created),
  145|      1|                    format_datetime_csv(project.modified),
  146|      1|                    project.area_uuid.map(|u| u.to_string()).unwrap_or_default(),
  147|       |                ));
  148|       |            }
  149|      1|        }
  150|       |
  151|       |        // Export areas
  152|      2|        if !data.areas.is_empty() {
  153|      1|            csv.push_str("\n\nAreas\n");
  154|      1|            csv.push_str("Title,Notes,Created,Modified\n");
  155|      3|            for area in &data.areas {
                              ^2
  156|      2|                csv.push_str(&format!(
  157|      2|                    "{},{},{},{}\n",
  158|      2|                    escape_csv(&area.title),
  159|      2|                    escape_csv(area.notes.as_deref().unwrap_or("")),
  160|      2|                    format_datetime_csv(area.created),
  161|      2|                    format_datetime_csv(area.modified),
  162|      2|                ));
  163|      2|            }
  164|      1|        }
  165|       |
  166|      2|        Ok(csv)
  167|      2|    }
  168|       |
  169|       |    /// Export as OPML
  170|      2|    fn export_opml(&self, data: &ExportData) -> Result<String> {
  171|      2|        let mut opml = String::new();
  172|      2|        opml.push_str("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
  173|      2|        opml.push_str("<opml version=\"2.0\">\n");
  174|      2|        opml.push_str("  <head>\n");
  175|      2|        opml.push_str(&format!(
  176|      2|            "    <title>Things 3 Export - {}</title>\n",
  177|      2|            data.exported_at.format("%Y-%m-%d %H:%M:%S")
  178|      2|        ));
  179|      2|        opml.push_str("  </head>\n");
  180|      2|        opml.push_str("  <body>\n");
  181|       |
  182|       |        // Group by areas
  183|      2|        let mut area_map: HashMap<Option<uuid::Uuid>, Vec<&Project>> = HashMap::new();
  184|      3|        for project in &data.projects {
                          ^1
  185|      1|            area_map.entry(project.area_uuid).or_default().push(project);
  186|      1|        }
  187|       |
  188|      4|        for area in &data.areas {
                          ^2
  189|      2|            opml.push_str(&format!(
  190|      2|                "    <outline text=\"{}\">\n",
  191|      2|                escape_xml(&area.title)
  192|      2|            ));
  193|       |
  194|      2|            if let Some(projects) = area_map.get(&Some(area.uuid)) {
                                      ^1
  195|      2|                for project in projects {
                                  ^1
  196|      1|                    opml.push_str(&format!(
  197|      1|                        "      <outline text=\"{}\" type=\"project\">\n",
  198|      1|                        escape_xml(&project.title)
  199|      1|                    ));
  200|       |
  201|       |                    // Add tasks for this project
  202|      3|                    for task in &data.tasks {
                                      ^2
  203|      2|                        if task.project_uuid == Some(project.uuid) {
  204|      0|                            opml.push_str(&format!(
  205|      0|                                "        <outline text=\"{}\" type=\"task\"/>\n",
  206|      0|                                escape_xml(&task.title)
  207|      0|                            ));
  208|      2|                        }
  209|       |                    }
  210|       |
  211|      1|                    opml.push_str("      </outline>\n");
  212|       |                }
  213|      1|            }
  214|       |
  215|      2|            opml.push_str("    </outline>\n");
  216|       |        }
  217|       |
  218|      2|        opml.push_str("  </body>\n");
  219|      2|        opml.push_str("</opml>\n");
  220|      2|        Ok(opml)
  221|      2|    }
  222|       |
  223|       |    /// Export as Markdown
  224|      2|    fn export_markdown(&self, data: &ExportData) -> Result<String> {
  225|      2|        let mut md = String::new();
  226|       |
  227|      2|        md.push_str("# Things 3 Export\n\n");
  228|      2|        md.push_str(&format!(
  229|      2|            "**Exported:** {}\n",
  230|      2|            data.exported_at.format("%Y-%m-%d %H:%M:%S UTC")
  231|      2|        ));
  232|      2|        md.push_str(&format!("**Total Items:** {}\n\n", data.total_items));
  233|       |
  234|       |        // Export areas
  235|      2|        if !data.areas.is_empty() {
  236|      1|            md.push_str("## Areas\n\n");
  237|      3|            for area in &data.areas {
                              ^2
  238|      2|                md.push_str(&format!("### {}\n", area.title));
  239|      2|                if let Some(notes) = &area.notes {
  240|      2|                    md.push_str(&format!("{}\n\n", notes));
  241|      2|                }
                              ^0
  242|       |            }
  243|      1|        }
  244|       |
  245|       |        // Export projects
  246|      2|        if !data.projects.is_empty() {
  247|      1|            md.push_str("## Projects\n\n");
  248|      2|            for project in &data.projects {
                              ^1
  249|      1|                md.push_str(&format!("### {}\n", project.title));
  250|      1|                md.push_str(&format!("**Status:** {:?}\n", project.status));
  251|      1|                if let Some(notes) = &project.notes {
  252|      1|                    md.push_str(&format!("**Notes:** {}\n", notes));
  253|      1|                }
                              ^0
  254|      1|                if let Some(deadline) = &project.deadline {
  255|      1|                    md.push_str(&format!("**Deadline:** {}\n", deadline));
  256|      1|                }
                              ^0
  257|      1|                md.push('\n');
  258|       |            }
  259|      1|        }
  260|       |
  261|       |        // Export tasks
  262|      2|        if !data.tasks.is_empty() {
  263|      1|            md.push_str("## Tasks\n\n");
  264|      3|            for task in &data.tasks {
                              ^2
  265|      2|                md.push_str(&format!(
  266|      2|                    "- [{}] {}\n",
  267|      2|                    if task.status == TaskStatus::Completed {
  268|      0|                        "x"
  269|       |                    } else {
  270|      2|                        " "
  271|       |                    },
  272|       |                    task.title
  273|       |                ));
  274|      2|                if let Some(notes) = &task.notes {
  275|      2|                    md.push_str(&format!("  - {}\n", notes));
  276|      2|                }
                              ^0
  277|      2|                if let Some(deadline) = &task.deadline {
                                          ^1
  278|      1|                    md.push_str(&format!("  - **Deadline:** {}\n", deadline));
  279|      1|                }
  280|       |            }
  281|      1|        }
  282|       |
  283|      2|        Ok(md)
  284|      2|    }
  285|       |}
  286|       |
  287|       |/// Helper functions for CSV export
  288|      6|fn format_task_type_csv(task_type: &TaskType) -> &'static str {
  289|      6|    match task_type {
  290|      3|        TaskType::Todo => "Todo",
  291|      1|        TaskType::Project => "Project",
  292|      1|        TaskType::Heading => "Heading",
  293|      1|        TaskType::Area => "Area",
  294|       |    }
  295|      6|}
  296|       |
  297|      7|fn format_task_status_csv(status: &TaskStatus) -> &'static str {
  298|      7|    match status {
  299|      4|        TaskStatus::Incomplete => "Incomplete",
  300|      1|        TaskStatus::Completed => "Completed",
  301|      1|        TaskStatus::Canceled => "Canceled",
  302|      1|        TaskStatus::Trashed => "Trashed",
  303|       |    }
  304|      7|}
  305|       |
  306|      8|fn format_date_csv(date: Option<chrono::NaiveDate>) -> String {
  307|      8|    date.map(|d| d.format("%Y-%m-%d").to_string())
                               ^4                   ^4
  308|      8|        .unwrap_or_default()
  309|      8|}
  310|       |
  311|     11|fn format_datetime_csv(datetime: DateTime<Utc>) -> String {
  312|     11|    datetime.format("%Y-%m-%d %H:%M:%S").to_string()
  313|     11|}
  314|       |
  315|     15|fn escape_csv(s: &str) -> String {
  316|     15|    if s.contains(',') || s.contains('"') || s.contains('\n') {
                                        ^13^13              ^12^12
  317|      4|        format!("\"{}\"", s.replace('"', "\"\""))
  318|       |    } else {
  319|     11|        s.to_string()
  320|       |    }
  321|     15|}
  322|       |
  323|      9|fn escape_xml(s: &str) -> String {
  324|      9|    s.replace('&', "&amp;")
  325|      9|        .replace('<', "&lt;")
  326|      9|        .replace('>', "&gt;")
  327|      9|        .replace('"', "&quot;")
  328|      9|        .replace('\'', "&apos;")
  329|      9|}
  330|       |
  331|       |#[cfg(test)]
  332|       |mod tests {
  333|       |    use super::*;
  334|       |    use crate::test_utils::{create_mock_areas, create_mock_projects, create_mock_tasks};
  335|       |
  336|       |    #[test]
  337|      1|    fn test_export_format_from_str() {
  338|      1|        assert_eq!("json".parse::<ExportFormat>().unwrap(), ExportFormat::Json);
  339|      1|        assert_eq!("JSON".parse::<ExportFormat>().unwrap(), ExportFormat::Json);
  340|      1|        assert_eq!("csv".parse::<ExportFormat>().unwrap(), ExportFormat::Csv);
  341|      1|        assert_eq!("CSV".parse::<ExportFormat>().unwrap(), ExportFormat::Csv);
  342|      1|        assert_eq!("opml".parse::<ExportFormat>().unwrap(), ExportFormat::Opml);
  343|      1|        assert_eq!("OPML".parse::<ExportFormat>().unwrap(), ExportFormat::Opml);
  344|      1|        assert_eq!(
  345|      1|            "markdown".parse::<ExportFormat>().unwrap(),
  346|       |            ExportFormat::Markdown
  347|       |        );
  348|      1|        assert_eq!(
  349|      1|            "Markdown".parse::<ExportFormat>().unwrap(),
  350|       |            ExportFormat::Markdown
  351|       |        );
  352|      1|        assert_eq!(
  353|      1|            "md".parse::<ExportFormat>().unwrap(),
  354|       |            ExportFormat::Markdown
  355|       |        );
  356|      1|        assert_eq!(
  357|      1|            "MD".parse::<ExportFormat>().unwrap(),
  358|       |            ExportFormat::Markdown
  359|       |        );
  360|       |
  361|      1|        assert!("invalid".parse::<ExportFormat>().is_err());
  362|      1|        assert!("".parse::<ExportFormat>().is_err());
  363|      1|    }
  364|       |
  365|       |    #[test]
  366|      1|    fn test_export_data_new() {
  367|      1|        let tasks = create_mock_tasks();
  368|      1|        let projects = create_mock_projects();
  369|      1|        let areas = create_mock_areas();
  370|       |
  371|      1|        let data = ExportData::new(tasks.clone(), projects.clone(), areas.clone());
  372|       |
  373|      1|        assert_eq!(data.tasks.len(), tasks.len());
  374|      1|        assert_eq!(data.projects.len(), projects.len());
  375|      1|        assert_eq!(data.areas.len(), areas.len());
  376|      1|        assert_eq!(data.total_items, tasks.len() + projects.len() + areas.len());
  377|      1|        assert!(data.exported_at <= Utc::now());
  378|      1|    }
  379|       |
  380|       |    #[test]
  381|      1|    fn test_export_config_default() {
  382|      1|        let config = ExportConfig::default();
  383|       |
  384|      1|        assert!(config.include_metadata);
  385|      1|        assert!(config.include_notes);
  386|      1|        assert!(config.include_tags);
  387|      1|        assert_eq!(config.date_format, "%Y-%m-%d %H:%M:%S");
  388|      1|        assert_eq!(config.timezone, "UTC");
  389|      1|    }
  390|       |
  391|       |    #[test]
  392|      1|    fn test_data_exporter_new() {
  393|      1|        let config = ExportConfig::default();
  394|      1|        let _exporter = DataExporter::new(config);
  395|       |        // Just test that it can be created
  396|       |        // Test passes if we reach this point
  397|      1|    }
  398|       |
  399|       |    #[test]
  400|      1|    fn test_data_exporter_new_default() {
  401|      1|        let _exporter = DataExporter::new_default();
  402|       |        // Just test that it can be created
  403|       |        // Test passes if we reach this point
  404|      1|    }
  405|       |
  406|       |    #[test]
  407|      1|    fn test_export_json_empty() {
  408|      1|        let exporter = DataExporter::new_default();
  409|      1|        let data = ExportData::new(vec![], vec![], vec![]);
  410|      1|        let result = exporter.export(&data, ExportFormat::Json);
  411|      1|        assert!(result.is_ok());
  412|       |
  413|      1|        let json = result.unwrap();
  414|      1|        assert!(json.contains("\"tasks\""));
  415|      1|        assert!(json.contains("\"projects\""));
  416|      1|        assert!(json.contains("\"areas\""));
  417|      1|        assert!(json.contains("\"exported_at\""));
  418|      1|        assert!(json.contains("\"total_items\""));
  419|      1|    }
  420|       |
  421|       |    #[test]
  422|      1|    fn test_export_json_with_data() {
  423|      1|        let exporter = DataExporter::new_default();
  424|      1|        let tasks = create_mock_tasks();
  425|      1|        let projects = create_mock_projects();
  426|      1|        let areas = create_mock_areas();
  427|      1|        let data = ExportData::new(tasks, projects, areas);
  428|       |
  429|      1|        let result = exporter.export(&data, ExportFormat::Json);
  430|      1|        assert!(result.is_ok());
  431|       |
  432|      1|        let json = result.unwrap();
  433|      1|        assert!(json.contains("\"Review quarterly reports\""));
  434|      1|        assert!(json.contains("\"Website Redesign\""));
  435|      1|        assert!(json.contains("\"Work\""));
  436|      1|    }
  437|       |
  438|       |    #[test]
  439|      1|    fn test_export_csv_empty() {
  440|      1|        let exporter = DataExporter::new_default();
  441|      1|        let data = ExportData::new(vec![], vec![], vec![]);
  442|      1|        let result = exporter.export(&data, ExportFormat::Csv);
  443|      1|        assert!(result.is_ok());
  444|       |
  445|      1|        let csv = result.unwrap();
  446|      1|        assert!(csv.is_empty());
  447|      1|    }
  448|       |
  449|       |    #[test]
  450|      1|    fn test_export_csv_with_data() {
  451|      1|        let exporter = DataExporter::new_default();
  452|      1|        let tasks = create_mock_tasks();
  453|      1|        let projects = create_mock_projects();
  454|      1|        let areas = create_mock_areas();
  455|      1|        let data = ExportData::new(tasks, projects, areas);
  456|       |
  457|      1|        let result = exporter.export(&data, ExportFormat::Csv);
  458|      1|        assert!(result.is_ok());
  459|       |
  460|      1|        let csv = result.unwrap();
  461|      1|        assert!(csv.contains(
  462|      1|            "Type,Title,Status,Notes,Start Date,Deadline,Created,Modified,Project,Area,Parent"
  463|      1|        ));
  464|      1|        assert!(csv.contains("Review quarterly reports"));
  465|      1|        assert!(csv.contains("Projects"));
  466|      1|        assert!(csv.contains("Website Redesign"));
  467|      1|        assert!(csv.contains("Areas"));
  468|      1|        assert!(csv.contains("Work"));
  469|      1|    }
  470|       |
  471|       |    #[test]
  472|      1|    fn test_export_markdown_empty() {
  473|      1|        let exporter = DataExporter::new_default();
  474|      1|        let data = ExportData::new(vec![], vec![], vec![]);
  475|      1|        let result = exporter.export(&data, ExportFormat::Markdown);
  476|      1|        assert!(result.is_ok());
  477|       |
  478|      1|        let md = result.unwrap();
  479|      1|        assert!(md.contains("# Things 3 Export"));
  480|      1|        assert!(md.contains("**Total Items:** 0"));
  481|      1|    }
  482|       |
  483|       |    #[test]
  484|      1|    fn test_export_markdown_with_data() {
  485|      1|        let exporter = DataExporter::new_default();
  486|      1|        let tasks = create_mock_tasks();
  487|      1|        let projects = create_mock_projects();
  488|      1|        let areas = create_mock_areas();
  489|      1|        let data = ExportData::new(tasks, projects, areas);
  490|       |
  491|      1|        let result = exporter.export(&data, ExportFormat::Markdown);
  492|      1|        assert!(result.is_ok());
  493|       |
  494|      1|        let md = result.unwrap();
  495|      1|        assert!(md.contains("# Things 3 Export"));
  496|      1|        assert!(md.contains("## Areas"));
  497|      1|        assert!(md.contains("### Work"));
  498|      1|        assert!(md.contains("## Projects"));
  499|      1|        assert!(md.contains("### Website Redesign"));
  500|      1|        assert!(md.contains("## Tasks"));
  501|      1|        assert!(md.contains("- [ ] Review quarterly reports"));
  502|      1|    }
  503|       |
  504|       |    #[test]
  505|      1|    fn test_export_opml_empty() {
  506|      1|        let exporter = DataExporter::new_default();
  507|      1|        let data = ExportData::new(vec![], vec![], vec![]);
  508|      1|        let result = exporter.export(&data, ExportFormat::Opml);
  509|      1|        assert!(result.is_ok());
  510|       |
  511|      1|        let opml = result.unwrap();
  512|      1|        assert!(opml.contains("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));
  513|      1|        assert!(opml.contains("<opml version=\"2.0\">"));
  514|      1|        assert!(opml.contains("<head>"));
  515|      1|        assert!(opml.contains("<body>"));
  516|      1|        assert!(opml.contains("</opml>"));
  517|      1|    }
  518|       |
  519|       |    #[test]
  520|      1|    fn test_export_opml_with_data() {
  521|      1|        let exporter = DataExporter::new_default();
  522|      1|        let tasks = create_mock_tasks();
  523|      1|        let projects = create_mock_projects();
  524|      1|        let areas = create_mock_areas();
  525|      1|        let data = ExportData::new(tasks, projects, areas);
  526|       |
  527|      1|        let result = exporter.export(&data, ExportFormat::Opml);
  528|      1|        assert!(result.is_ok());
  529|       |
  530|      1|        let opml = result.unwrap();
  531|      1|        assert!(opml.contains("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));
  532|      1|        assert!(opml.contains("<opml version=\"2.0\">"));
  533|      1|        assert!(opml.contains("Work"));
  534|      1|        assert!(opml.contains("Website Redesign"));
  535|      1|    }
  536|       |
  537|       |    #[test]
  538|      1|    fn test_format_task_type_csv() {
  539|      1|        assert_eq!(format_task_type_csv(&TaskType::Todo), "Todo");
  540|      1|        assert_eq!(format_task_type_csv(&TaskType::Project), "Project");
  541|      1|        assert_eq!(format_task_type_csv(&TaskType::Heading), "Heading");
  542|      1|        assert_eq!(format_task_type_csv(&TaskType::Area), "Area");
  543|      1|    }
  544|       |
  545|       |    #[test]
  546|      1|    fn test_format_task_status_csv() {
  547|      1|        assert_eq!(
  548|      1|            format_task_status_csv(&TaskStatus::Incomplete),
  549|       |            "Incomplete"
  550|       |        );
  551|      1|        assert_eq!(format_task_status_csv(&TaskStatus::Completed), "Completed");
  552|      1|        assert_eq!(format_task_status_csv(&TaskStatus::Canceled), "Canceled");
  553|      1|        assert_eq!(format_task_status_csv(&TaskStatus::Trashed), "Trashed");
  554|      1|    }
  555|       |
  556|       |    #[test]
  557|      1|    fn test_format_date_csv() {
  558|       |        use chrono::NaiveDate;
  559|       |
  560|      1|        let date = NaiveDate::from_ymd_opt(2023, 12, 25).unwrap();
  561|      1|        assert_eq!(format_date_csv(Some(date)), "2023-12-25");
  562|      1|        assert_eq!(format_date_csv(None), "");
  563|      1|    }
  564|       |
  565|       |    #[test]
  566|      1|    fn test_format_datetime_csv() {
  567|      1|        let datetime = Utc::now();
  568|      1|        let formatted = format_datetime_csv(datetime);
  569|      1|        assert!(
  570|      1|            formatted.contains("2023") || formatted.contains("2024") || formatted.contains("2025")
  571|       |        );
  572|      1|        assert!(formatted.contains("-"));
  573|      1|        assert!(formatted.contains(" "));
  574|      1|        assert!(formatted.contains(":"));
  575|      1|    }
  576|       |
  577|       |    #[test]
  578|      1|    fn test_escape_csv() {
  579|       |        // No special characters
  580|      1|        assert_eq!(escape_csv("normal text"), "normal text");
  581|       |
  582|       |        // Contains comma
  583|      1|        assert_eq!(escape_csv("text,with,comma"), "\"text,with,comma\"");
  584|       |
  585|       |        // Contains quote
  586|      1|        assert_eq!(escape_csv("text\"with\"quote"), "\"text\"\"with\"\"quote\"");
  587|       |
  588|       |        // Contains newline
  589|      1|        assert_eq!(escape_csv("text\nwith\nnewline"), "\"text\nwith\nnewline\"");
  590|       |
  591|       |        // Contains multiple special characters
  592|      1|        assert_eq!(
  593|      1|            escape_csv("text,\"with\",\nall"),
  594|       |            "\"text,\"\"with\"\",\nall\""
  595|       |        );
  596|      1|    }
  597|       |
  598|       |    #[test]
  599|      1|    fn test_escape_xml() {
  600|      1|        assert_eq!(escape_xml("normal text"), "normal text");
  601|      1|        assert_eq!(
  602|      1|            escape_xml("text&with&ampersand"),
  603|       |            "text&amp;with&amp;ampersand"
  604|       |        );
  605|      1|        assert_eq!(escape_xml("text<with>tags"), "text&lt;with&gt;tags");
  606|      1|        assert_eq!(
  607|      1|            escape_xml("text\"with\"quotes"),
  608|       |            "text&quot;with&quot;quotes"
  609|       |        );
  610|      1|        assert_eq!(
  611|      1|            escape_xml("text'with'apostrophe"),
  612|       |            "text&apos;with&apos;apostrophe"
  613|       |        );
  614|      1|        assert_eq!(escape_xml("all<>&\"'"), "all&lt;&gt;&amp;&quot;&apos;");
  615|      1|    }
  616|       |
  617|       |    #[test]
  618|      1|    fn test_export_data_serialization() {
  619|      1|        let tasks = create_mock_tasks();
  620|      1|        let projects = create_mock_projects();
  621|      1|        let areas = create_mock_areas();
  622|      1|        let data = ExportData::new(tasks, projects, areas);
  623|       |
  624|       |        // Test that ExportData can be serialized and deserialized
  625|      1|        let json = serde_json::to_string(&data).unwrap();
  626|      1|        let deserialized: ExportData = serde_json::from_str(&json).unwrap();
  627|       |
  628|      1|        assert_eq!(data.tasks.len(), deserialized.tasks.len());
  629|      1|        assert_eq!(data.projects.len(), deserialized.projects.len());
  630|      1|        assert_eq!(data.areas.len(), deserialized.areas.len());
  631|      1|        assert_eq!(data.total_items, deserialized.total_items);
  632|      1|    }
  633|       |
  634|       |    #[test]
  635|      1|    fn test_export_config_clone() {
  636|      1|        let config = ExportConfig::default();
  637|      1|        let cloned = config.clone();
  638|       |
  639|      1|        assert_eq!(config.include_metadata, cloned.include_metadata);
  640|      1|        assert_eq!(config.include_notes, cloned.include_notes);
  641|      1|        assert_eq!(config.include_tags, cloned.include_tags);
  642|      1|        assert_eq!(config.date_format, cloned.date_format);
  643|      1|        assert_eq!(config.timezone, cloned.timezone);
  644|      1|    }
  645|       |
  646|       |    #[test]
  647|      1|    fn test_export_format_debug() {
  648|      1|        let formats = vec![
  649|      1|            ExportFormat::Json,
  650|      1|            ExportFormat::Csv,
  651|      1|            ExportFormat::Opml,
  652|      1|            ExportFormat::Markdown,
  653|       |        ];
  654|       |
  655|      5|        for format in formats {
                          ^4
  656|      4|            let debug_str = format!("{:?}", format);
  657|      4|            assert!(!debug_str.is_empty());
  658|       |        }
  659|      1|    }
  660|       |
  661|       |    #[test]
  662|      1|    fn test_export_format_equality() {
  663|      1|        assert_eq!(ExportFormat::Json, ExportFormat::Json);
  664|      1|        assert_eq!(ExportFormat::Csv, ExportFormat::Csv);
  665|      1|        assert_eq!(ExportFormat::Opml, ExportFormat::Opml);
  666|      1|        assert_eq!(ExportFormat::Markdown, ExportFormat::Markdown);
  667|       |
  668|      1|        assert_ne!(ExportFormat::Json, ExportFormat::Csv);
  669|      1|        assert_ne!(ExportFormat::Csv, ExportFormat::Opml);
  670|      1|        assert_ne!(ExportFormat::Opml, ExportFormat::Markdown);
  671|      1|        assert_ne!(ExportFormat::Markdown, ExportFormat::Json);
  672|      1|    }
  673|       |
  674|       |    #[test]
  675|      1|    fn test_export_data_debug() {
  676|      1|        let data = ExportData::new(vec![], vec![], vec![]);
  677|      1|        let debug_str = format!("{:?}", data);
  678|      1|        assert!(!debug_str.is_empty());
  679|      1|        assert!(debug_str.contains("ExportData"));
  680|      1|    }
  681|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/performance.rs:
    1|       |//! Performance monitoring and metrics for Things 3 operations
    2|       |
    3|       |use anyhow::Result;
    4|       |use chrono::{DateTime, Utc};
    5|       |use parking_lot::RwLock;
    6|       |use serde::{Deserialize, Serialize};
    7|       |use std::collections::HashMap;
    8|       |use std::sync::Arc;
    9|       |use std::time::{Duration, Instant};
   10|       |use sysinfo::System;
   11|       |
   12|       |/// Performance metrics for a single operation
   13|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   14|       |pub struct OperationMetrics {
   15|       |    pub operation_name: String,
   16|       |    pub duration: Duration,
   17|       |    pub timestamp: DateTime<Utc>,
   18|       |    pub success: bool,
   19|       |    pub error_message: Option<String>,
   20|       |}
   21|       |
   22|       |/// Aggregated performance statistics
   23|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   24|       |pub struct PerformanceStats {
   25|       |    pub operation_name: String,
   26|       |    pub total_calls: u64,
   27|       |    pub successful_calls: u64,
   28|       |    pub failed_calls: u64,
   29|       |    pub total_duration: Duration,
   30|       |    pub average_duration: Duration,
   31|       |    pub min_duration: Duration,
   32|       |    pub max_duration: Duration,
   33|       |    pub success_rate: f64,
   34|       |    pub last_called: Option<DateTime<Utc>>,
   35|       |}
   36|       |
   37|       |impl PerformanceStats {
   38|     11|    pub fn new(operation_name: String) -> Self {
   39|     11|        Self {
   40|     11|            operation_name,
   41|     11|            total_calls: 0,
   42|     11|            successful_calls: 0,
   43|     11|            failed_calls: 0,
   44|     11|            total_duration: Duration::ZERO,
   45|     11|            average_duration: Duration::ZERO,
   46|     11|            min_duration: Duration::MAX,
   47|     11|            max_duration: Duration::ZERO,
   48|     11|            success_rate: 0.0,
   49|     11|            last_called: None,
   50|     11|        }
   51|     11|    }
   52|       |
   53|     18|    pub fn add_metric(&mut self, metric: &OperationMetrics) {
   54|     18|        self.total_calls += 1;
   55|     18|        self.total_duration += metric.duration;
   56|     18|        self.last_called = Some(metric.timestamp);
   57|       |
   58|     18|        if metric.success {
   59|     12|            self.successful_calls += 1;
   60|     12|        } else {
   61|      6|            self.failed_calls += 1;
   62|      6|        }
   63|       |
   64|     18|        if metric.duration < self.min_duration {
   65|     11|            self.min_duration = metric.duration;
   66|     11|        }
                      ^7
   67|     18|        if metric.duration > self.max_duration {
   68|     15|            self.max_duration = metric.duration;
   69|     15|        }
                      ^3
   70|       |
   71|     18|        self.average_duration =
   72|     18|            Duration::from_nanos(self.total_duration.as_nanos() as u64 / self.total_calls);
   73|       |
   74|     18|        self.success_rate = if self.total_calls > 0 {
   75|     18|            self.successful_calls as f64 / self.total_calls as f64
   76|       |        } else {
   77|      0|            0.0
   78|       |        };
   79|     18|    }
   80|       |}
   81|       |
   82|       |/// System resource metrics
   83|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   84|       |pub struct SystemMetrics {
   85|       |    pub timestamp: DateTime<Utc>,
   86|       |    pub memory_usage_mb: f64,
   87|       |    pub cpu_usage_percent: f64,
   88|       |    pub available_memory_mb: f64,
   89|       |    pub total_memory_mb: f64,
   90|       |}
   91|       |
   92|       |/// Performance monitor for tracking operations and system metrics
   93|       |pub struct PerformanceMonitor {
   94|       |    /// Individual operation metrics
   95|       |    metrics: Arc<RwLock<Vec<OperationMetrics>>>,
   96|       |    /// Aggregated statistics by operation name
   97|       |    stats: Arc<RwLock<HashMap<String, PerformanceStats>>>,
   98|       |    /// System information
   99|       |    system: Arc<RwLock<System>>,
  100|       |    /// Maximum number of metrics to keep in memory
  101|       |    max_metrics: usize,
  102|       |}
  103|       |
  104|       |impl PerformanceMonitor {
  105|       |    /// Create a new performance monitor
  106|     48|    pub fn new(max_metrics: usize) -> Self {
  107|     48|        Self {
  108|     48|            metrics: Arc::new(RwLock::new(Vec::new())),
  109|     48|            stats: Arc::new(RwLock::new(HashMap::new())),
  110|     48|            system: Arc::new(RwLock::new(System::new_all())),
  111|     48|            max_metrics,
  112|     48|        }
  113|     48|    }
  114|       |
  115|       |    /// Create a new performance monitor with default settings
  116|     48|    pub fn new_default() -> Self {
  117|     48|        Self::new(10000) // Keep last 10,000 metrics
  118|     48|    }
  119|       |
  120|       |    /// Start timing an operation
  121|      2|    pub fn start_operation(&self, operation_name: &str) -> OperationTimer {
  122|      2|        OperationTimer {
  123|      2|            monitor: self.clone(),
  124|      2|            operation_name: operation_name.to_string(),
  125|      2|            start_time: Instant::now(),
  126|      2|        }
  127|      2|    }
  128|       |
  129|       |    /// Record a completed operation
  130|     18|    pub fn record_operation(&self, metric: OperationMetrics) {
  131|       |        // Add to metrics list
  132|       |        {
  133|     18|            let mut metrics = self.metrics.write();
  134|     18|            metrics.push(metric.clone());
  135|       |
  136|       |            // Trim if we exceed max_metrics
  137|     18|            if metrics.len() > self.max_metrics {
  138|      0|                let excess = metrics.len() - self.max_metrics;
  139|      0|                metrics.drain(0..excess);
  140|     18|            }
  141|       |        }
  142|       |
  143|       |        // Update aggregated stats
  144|       |        {
  145|     18|            let mut stats = self.stats.write();
  146|     18|            let operation_stats = stats
  147|     18|                .entry(metric.operation_name.clone())
  148|     18|                .or_insert_with(|| PerformanceStats::new(metric.operation_name.clone()));
                                                 ^11                   ^11                   ^11
  149|     18|            operation_stats.add_metric(&metric);
  150|       |        }
  151|     18|    }
  152|       |
  153|       |    /// Get all operation metrics
  154|      0|    pub fn get_metrics(&self) -> Vec<OperationMetrics> {
  155|      0|        self.metrics.read().clone()
  156|      0|    }
  157|       |
  158|       |    /// Get aggregated statistics for all operations
  159|      5|    pub fn get_all_stats(&self) -> HashMap<String, PerformanceStats> {
  160|      5|        self.stats.read().clone()
  161|      5|    }
  162|       |
  163|       |    /// Get statistics for a specific operation
  164|      8|    pub fn get_operation_stats(&self, operation_name: &str) -> Option<PerformanceStats> {
  165|      8|        self.stats.read().get(operation_name).cloned()
  166|      8|    }
  167|       |
  168|       |    /// Get current system metrics
  169|      1|    pub fn get_system_metrics(&self) -> Result<SystemMetrics> {
  170|      1|        let mut system = self.system.write();
  171|      1|        system.refresh_all();
  172|       |
  173|       |        Ok(SystemMetrics {
  174|      1|            timestamp: Utc::now(),
  175|      1|            memory_usage_mb: system.used_memory() as f64 / 1024.0 / 1024.0,
  176|      1|            cpu_usage_percent: system
  177|      1|                .cpus()
  178|      1|                .iter()
  179|     16|                .map(|cpu| cpu.cpu_usage() as f64)
                               ^1
  180|      1|                .sum::<f64>()
  181|      1|                / system.cpus().len() as f64,
  182|      1|            available_memory_mb: system.available_memory() as f64 / 1024.0 / 1024.0,
  183|      1|            total_memory_mb: system.total_memory() as f64 / 1024.0 / 1024.0,
  184|       |        })
  185|      1|    }
  186|       |
  187|       |    /// Clear all metrics and statistics
  188|      0|    pub fn clear(&self) {
  189|      0|        self.metrics.write().clear();
  190|      0|        self.stats.write().clear();
  191|      0|    }
  192|       |
  193|       |    /// Get performance summary
  194|      3|    pub fn get_summary(&self) -> PerformanceSummary {
  195|      3|        let stats = self.get_all_stats();
  196|      3|        let total_operations: u64 = stats.values().map(|s| s.total_calls).sum();
  197|      3|        let total_successful: u64 = stats.values().map(|s| s.successful_calls).sum();
  198|      3|        let total_duration: Duration = stats.values().map(|s| s.total_duration).sum();
  199|       |
  200|       |        PerformanceSummary {
  201|      3|            total_operations,
  202|      3|            total_successful,
  203|      3|            total_failed: total_operations - total_successful,
  204|      3|            overall_success_rate: if total_operations > 0 {
  205|      1|                total_successful as f64 / total_operations as f64
  206|       |            } else {
  207|      2|                0.0
  208|       |            },
  209|      3|            total_duration,
  210|      3|            average_operation_duration: if total_operations > 0 {
  211|      1|                Duration::from_nanos(total_duration.as_nanos() as u64 / total_operations)
  212|       |            } else {
  213|      2|                Duration::ZERO
  214|       |            },
  215|      3|            operation_count: stats.len(),
  216|       |        }
  217|      3|    }
  218|       |}
  219|       |
  220|       |impl Clone for PerformanceMonitor {
  221|      3|    fn clone(&self) -> Self {
  222|      3|        Self {
  223|      3|            metrics: Arc::clone(&self.metrics),
  224|      3|            stats: Arc::clone(&self.stats),
  225|      3|            system: Arc::clone(&self.system),
  226|      3|            max_metrics: self.max_metrics,
  227|      3|        }
  228|      3|    }
  229|       |}
  230|       |
  231|       |/// Timer for tracking operation duration
  232|       |pub struct OperationTimer {
  233|       |    monitor: PerformanceMonitor,
  234|       |    operation_name: String,
  235|       |    start_time: Instant,
  236|       |}
  237|       |
  238|       |impl OperationTimer {
  239|       |    /// Complete the operation successfully
  240|      2|    pub fn success(self) {
  241|      2|        let duration = self.start_time.elapsed();
  242|      2|        let metric = OperationMetrics {
  243|      2|            operation_name: self.operation_name,
  244|      2|            duration,
  245|      2|            timestamp: Utc::now(),
  246|      2|            success: true,
  247|      2|            error_message: None,
  248|      2|        };
  249|      2|        self.monitor.record_operation(metric);
  250|      2|    }
  251|       |
  252|       |    /// Complete the operation with an error
  253|      0|    pub fn error(self, error_message: String) {
  254|      0|        let duration = self.start_time.elapsed();
  255|      0|        let metric = OperationMetrics {
  256|      0|            operation_name: self.operation_name,
  257|      0|            duration,
  258|      0|            timestamp: Utc::now(),
  259|      0|            success: false,
  260|      0|            error_message: Some(error_message),
  261|      0|        };
  262|      0|        self.monitor.record_operation(metric);
  263|      0|    }
  264|       |}
  265|       |
  266|       |/// Performance summary
  267|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  268|       |pub struct PerformanceSummary {
  269|       |    pub total_operations: u64,
  270|       |    pub total_successful: u64,
  271|       |    pub total_failed: u64,
  272|       |    pub overall_success_rate: f64,
  273|       |    pub total_duration: Duration,
  274|       |    pub average_operation_duration: Duration,
  275|       |    pub operation_count: usize,
  276|       |}
  277|       |
  278|       |#[cfg(test)]
  279|       |mod tests {
  280|       |    use super::*;
  281|       |    use std::thread;
  282|       |
  283|       |    #[test]
  284|      1|    fn test_performance_monitor() {
  285|      1|        let monitor = PerformanceMonitor::new_default();
  286|       |
  287|       |        // Record some operations
  288|      1|        let metric1 = OperationMetrics {
  289|      1|            operation_name: "test_op".to_string(),
  290|      1|            duration: Duration::from_millis(100),
  291|      1|            timestamp: Utc::now(),
  292|      1|            success: true,
  293|      1|            error_message: None,
  294|      1|        };
  295|       |
  296|      1|        monitor.record_operation(metric1);
  297|       |
  298|      1|        let stats = monitor.get_operation_stats("test_op");
  299|      1|        assert!(stats.is_some());
  300|      1|        let stats = stats.unwrap();
  301|      1|        assert_eq!(stats.total_calls, 1);
  302|      1|        assert_eq!(stats.successful_calls, 1);
  303|      1|        assert_eq!(stats.failed_calls, 0);
  304|      1|    }
  305|       |
  306|       |    #[test]
  307|      1|    fn test_operation_timer() {
  308|      1|        let monitor = PerformanceMonitor::new_default();
  309|       |
  310|       |        // Test successful operation
  311|      1|        let timer = monitor.start_operation("test_timer");
  312|      1|        thread::sleep(Duration::from_millis(10));
  313|      1|        timer.success();
  314|       |
  315|      1|        let stats = monitor.get_operation_stats("test_timer");
  316|      1|        assert!(stats.is_some());
  317|      1|        let stats = stats.unwrap();
  318|      1|        assert_eq!(stats.total_calls, 1);
  319|      1|        assert!(stats.successful_calls > 0);
  320|      1|    }
  321|       |
  322|       |    #[test]
  323|      1|    fn test_performance_monitor_failed_operation() {
  324|      1|        let monitor = PerformanceMonitor::new_default();
  325|       |
  326|       |        // Record a failed operation
  327|      1|        let metric = OperationMetrics {
  328|      1|            operation_name: "failed_op".to_string(),
  329|      1|            duration: Duration::from_millis(50),
  330|      1|            timestamp: Utc::now(),
  331|      1|            success: false,
  332|      1|            error_message: Some("Test error".to_string()),
  333|      1|        };
  334|       |
  335|      1|        monitor.record_operation(metric);
  336|       |
  337|      1|        let stats = monitor.get_operation_stats("failed_op");
  338|      1|        assert!(stats.is_some());
  339|      1|        let stats = stats.unwrap();
  340|      1|        assert_eq!(stats.total_calls, 1);
  341|      1|        assert_eq!(stats.successful_calls, 0);
  342|      1|        assert_eq!(stats.failed_calls, 1);
  343|      1|    }
  344|       |
  345|       |    #[test]
  346|      1|    fn test_performance_monitor_multiple_operations() {
  347|      1|        let monitor = PerformanceMonitor::new_default();
  348|       |
  349|       |        // Record multiple operations
  350|      6|        for i in 0..5 {
                          ^5
  351|      5|            let metric = OperationMetrics {
  352|      5|                operation_name: "multi_op".to_string(),
  353|      5|                duration: Duration::from_millis(i * 10),
  354|      5|                timestamp: Utc::now(),
  355|      5|                success: i % 2 == 0,
  356|      5|                error_message: if i % 2 == 0 {
  357|      3|                    None
  358|       |                } else {
  359|      2|                    Some("Error".to_string())
  360|       |                },
  361|       |            };
  362|      5|            monitor.record_operation(metric);
  363|       |        }
  364|       |
  365|      1|        let stats = monitor.get_operation_stats("multi_op");
  366|      1|        assert!(stats.is_some());
  367|      1|        let stats = stats.unwrap();
  368|      1|        assert_eq!(stats.total_calls, 5);
  369|      1|        assert_eq!(stats.successful_calls, 3);
  370|      1|        assert_eq!(stats.failed_calls, 2);
  371|      1|    }
  372|       |
  373|       |    #[test]
  374|      1|    fn test_performance_monitor_get_all_stats() {
  375|      1|        let monitor = PerformanceMonitor::new_default();
  376|       |
  377|       |        // Record operations for different types
  378|      1|        let operations = vec![("op1", true), ("op1", false), ("op2", true), ("op2", true)];
  379|       |
  380|      5|        for (name, success) in operations {
                           ^4    ^4
  381|      4|            let metric = OperationMetrics {
  382|      4|                operation_name: name.to_string(),
  383|      4|                duration: Duration::from_millis(100),
  384|      4|                timestamp: Utc::now(),
  385|      4|                success,
  386|      4|                error_message: if success {
  387|      3|                    None
  388|       |                } else {
  389|      1|                    Some("Error".to_string())
  390|       |                },
  391|       |            };
  392|      4|            monitor.record_operation(metric);
  393|       |        }
  394|       |
  395|      1|        let all_stats = monitor.get_all_stats();
  396|      1|        assert_eq!(all_stats.len(), 2);
  397|      1|        assert!(all_stats.contains_key("op1"));
  398|      1|        assert!(all_stats.contains_key("op2"));
  399|       |
  400|      1|        let op1_stats = &all_stats["op1"];
  401|      1|        assert_eq!(op1_stats.total_calls, 2);
  402|      1|        assert_eq!(op1_stats.successful_calls, 1);
  403|      1|        assert_eq!(op1_stats.failed_calls, 1);
  404|       |
  405|      1|        let op2_stats = &all_stats["op2"];
  406|      1|        assert_eq!(op2_stats.total_calls, 2);
  407|      1|        assert_eq!(op2_stats.successful_calls, 2);
  408|      1|        assert_eq!(op2_stats.failed_calls, 0);
  409|      1|    }
  410|       |
  411|       |    #[test]
  412|      1|    fn test_performance_monitor_get_summary() {
  413|      1|        let monitor = PerformanceMonitor::new_default();
  414|       |
  415|       |        // Record some operations
  416|      1|        let operations = vec![("op1", true, 100), ("op1", false, 200), ("op2", true, 150)];
  417|       |
  418|      4|        for (name, success, duration_ms) in operations {
                           ^3    ^3       ^3
  419|      3|            let metric = OperationMetrics {
  420|      3|                operation_name: name.to_string(),
  421|      3|                duration: Duration::from_millis(duration_ms),
  422|      3|                timestamp: Utc::now(),
  423|      3|                success,
  424|      3|                error_message: if success {
  425|      2|                    None
  426|       |                } else {
  427|      1|                    Some("Error".to_string())
  428|       |                },
  429|       |            };
  430|      3|            monitor.record_operation(metric);
  431|       |        }
  432|       |
  433|      1|        let summary = monitor.get_summary();
  434|      1|        assert_eq!(summary.total_operations, 3);
  435|      1|        assert_eq!(summary.total_successful, 2);
  436|      1|        assert_eq!(summary.total_failed, 1);
  437|      1|        assert!((summary.overall_success_rate - 2.0 / 3.0).abs() < 0.001);
  438|      1|        assert_eq!(summary.operation_count, 2);
  439|      1|    }
  440|       |
  441|       |    #[test]
  442|      1|    fn test_performance_monitor_get_summary_empty() {
  443|      1|        let monitor = PerformanceMonitor::new_default();
  444|      1|        let summary = monitor.get_summary();
  445|       |
  446|      1|        assert_eq!(summary.total_operations, 0);
  447|      1|        assert_eq!(summary.total_successful, 0);
  448|      1|        assert_eq!(summary.total_failed, 0);
  449|      1|        assert_eq!(summary.overall_success_rate, 0.0);
  450|      1|        assert_eq!(summary.operation_count, 0);
  451|      1|    }
  452|       |
  453|       |    #[test]
  454|      1|    fn test_operation_timer_failure() {
  455|      1|        let monitor = PerformanceMonitor::new_default();
  456|       |
  457|       |        // Test failed operation by recording it directly
  458|      1|        let metric = OperationMetrics {
  459|      1|            operation_name: "test_failure".to_string(),
  460|      1|            duration: Duration::from_millis(5),
  461|      1|            timestamp: Utc::now(),
  462|      1|            success: false,
  463|      1|            error_message: Some("Test failure".to_string()),
  464|      1|        };
  465|      1|        monitor.record_operation(metric);
  466|       |
  467|      1|        let stats = monitor.get_operation_stats("test_failure");
  468|      1|        assert!(stats.is_some());
  469|      1|        let stats = stats.unwrap();
  470|      1|        assert_eq!(stats.total_calls, 1);
  471|      1|        assert_eq!(stats.successful_calls, 0);
  472|      1|        assert_eq!(stats.failed_calls, 1);
  473|      1|    }
  474|       |
  475|       |    #[test]
  476|      1|    fn test_operation_timer_drop() {
  477|      1|        let monitor = PerformanceMonitor::new_default();
  478|       |
  479|       |        // Test that dropping the timer records the operation
  480|      1|        {
  481|      1|            let timer = monitor.start_operation("test_drop");
  482|      1|            thread::sleep(Duration::from_millis(5));
  483|      1|            // Explicitly call success before dropping
  484|      1|            timer.success();
  485|      1|        }
  486|       |
  487|      1|        let stats = monitor.get_operation_stats("test_drop");
  488|      1|        assert!(stats.is_some());
  489|      1|        let stats = stats.unwrap();
  490|      1|        assert_eq!(stats.total_calls, 1);
  491|      1|        assert_eq!(stats.successful_calls, 1);
  492|      1|        assert_eq!(stats.failed_calls, 0);
  493|      1|    }
  494|       |
  495|       |    #[test]
  496|      1|    fn test_performance_monitor_clone() {
  497|      1|        let monitor1 = PerformanceMonitor::new_default();
  498|       |
  499|       |        // Record an operation
  500|      1|        let metric = OperationMetrics {
  501|      1|            operation_name: "clone_test".to_string(),
  502|      1|            duration: Duration::from_millis(100),
  503|      1|            timestamp: Utc::now(),
  504|      1|            success: true,
  505|      1|            error_message: None,
  506|      1|        };
  507|      1|        monitor1.record_operation(metric);
  508|       |
  509|       |        // Clone the monitor
  510|      1|        let monitor2 = monitor1.clone();
  511|       |
  512|       |        // Both should have the same stats
  513|      1|        let stats1 = monitor1.get_operation_stats("clone_test");
  514|      1|        let stats2 = monitor2.get_operation_stats("clone_test");
  515|       |
  516|      1|        assert!(stats1.is_some());
  517|      1|        assert!(stats2.is_some());
  518|      1|        assert_eq!(stats1.unwrap().total_calls, stats2.unwrap().total_calls);
  519|      1|    }
  520|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/query.rs:
    1|       |//! Query builder for filtering and searching tasks
    2|       |
    3|       |use crate::models::{TaskFilters, TaskStatus, TaskType};
    4|       |use chrono::NaiveDate;
    5|       |use uuid::Uuid;
    6|       |
    7|       |/// Builder for constructing task queries with filters
    8|       |#[derive(Debug, Clone)]
    9|       |pub struct TaskQueryBuilder {
   10|       |    filters: TaskFilters,
   11|       |}
   12|       |
   13|       |impl TaskQueryBuilder {
   14|       |    /// Create a new query builder
   15|       |    #[must_use]
   16|     13|    pub fn new() -> Self {
   17|     13|        Self {
   18|     13|            filters: TaskFilters::default(),
   19|     13|        }
   20|     13|    }
   21|       |
   22|       |    /// Filter by status
   23|       |    #[must_use]
   24|      2|    pub fn status(mut self, status: TaskStatus) -> Self {
   25|      2|        self.filters.status = Some(status);
   26|      2|        self
   27|      2|    }
   28|       |
   29|       |    /// Filter by task type
   30|       |    #[must_use]
   31|      2|    pub fn task_type(mut self, task_type: TaskType) -> Self {
   32|      2|        self.filters.task_type = Some(task_type);
   33|      2|        self
   34|      2|    }
   35|       |
   36|       |    /// Filter by project UUID
   37|       |    #[must_use]
   38|      2|    pub fn project_uuid(mut self, project_uuid: Uuid) -> Self {
   39|      2|        self.filters.project_uuid = Some(project_uuid);
   40|      2|        self
   41|      2|    }
   42|       |
   43|       |    /// Filter by area UUID
   44|       |    #[must_use]
   45|      1|    pub fn area_uuid(mut self, area_uuid: Uuid) -> Self {
   46|      1|        self.filters.area_uuid = Some(area_uuid);
   47|      1|        self
   48|      1|    }
   49|       |
   50|       |    /// Filter by tags
   51|       |    #[must_use]
   52|      2|    pub fn tags(mut self, tags: Vec<String>) -> Self {
   53|      2|        self.filters.tags = Some(tags);
   54|      2|        self
   55|      2|    }
   56|       |
   57|       |    /// Filter by start date range
   58|       |    #[must_use]
   59|      2|    pub fn start_date_range(mut self, from: Option<NaiveDate>, to: Option<NaiveDate>) -> Self {
   60|      2|        self.filters.start_date_from = from;
   61|      2|        self.filters.start_date_to = to;
   62|      2|        self
   63|      2|    }
   64|       |
   65|       |    /// Filter by deadline range
   66|       |    #[must_use]
   67|      1|    pub fn deadline_range(mut self, from: Option<NaiveDate>, to: Option<NaiveDate>) -> Self {
   68|      1|        self.filters.deadline_from = from;
   69|      1|        self.filters.deadline_to = to;
   70|      1|        self
   71|      1|    }
   72|       |
   73|       |    /// Add search query
   74|       |    #[must_use]
   75|      2|    pub fn search(mut self, query: &str) -> Self {
   76|      2|        self.filters.search_query = Some(query.to_string());
   77|      2|        self
   78|      2|    }
   79|       |
   80|       |    /// Set limit
   81|       |    #[must_use]
   82|      2|    pub fn limit(mut self, limit: usize) -> Self {
   83|      2|        self.filters.limit = Some(limit);
   84|      2|        self
   85|      2|    }
   86|       |
   87|       |    /// Set offset for pagination
   88|       |    #[must_use]
   89|      2|    pub fn offset(mut self, offset: usize) -> Self {
   90|      2|        self.filters.offset = Some(offset);
   91|      2|        self
   92|      2|    }
   93|       |
   94|       |    /// Build the final filters
   95|       |    #[must_use]
   96|     13|    pub fn build(self) -> TaskFilters {
   97|     13|        self.filters
   98|     13|    }
   99|       |}
  100|       |
  101|       |impl Default for TaskQueryBuilder {
  102|      1|    fn default() -> Self {
  103|      1|        Self::new()
  104|      1|    }
  105|       |}
  106|       |
  107|       |#[cfg(test)]
  108|       |mod tests {
  109|       |    use super::*;
  110|       |    use chrono::NaiveDate;
  111|       |    use uuid::Uuid;
  112|       |
  113|       |    #[test]
  114|      1|    fn test_task_query_builder_new() {
  115|      1|        let builder = TaskQueryBuilder::new();
  116|      1|        let filters = builder.build();
  117|       |
  118|      1|        assert!(filters.status.is_none());
  119|      1|        assert!(filters.task_type.is_none());
  120|      1|        assert!(filters.project_uuid.is_none());
  121|      1|        assert!(filters.area_uuid.is_none());
  122|      1|        assert!(filters.tags.is_none());
  123|      1|        assert!(filters.start_date_from.is_none());
  124|      1|        assert!(filters.start_date_to.is_none());
  125|      1|        assert!(filters.deadline_from.is_none());
  126|      1|        assert!(filters.deadline_to.is_none());
  127|      1|        assert!(filters.search_query.is_none());
  128|      1|        assert!(filters.limit.is_none());
  129|      1|        assert!(filters.offset.is_none());
  130|      1|    }
  131|       |
  132|       |    #[test]
  133|      1|    fn test_task_query_builder_default() {
  134|      1|        let builder = TaskQueryBuilder::default();
  135|      1|        let filters = builder.build();
  136|       |
  137|      1|        assert!(filters.status.is_none());
  138|      1|        assert!(filters.task_type.is_none());
  139|      1|    }
  140|       |
  141|       |    #[test]
  142|      1|    fn test_task_query_builder_status() {
  143|      1|        let builder = TaskQueryBuilder::new().status(TaskStatus::Completed);
  144|      1|        let filters = builder.build();
  145|       |
  146|      1|        assert_eq!(filters.status, Some(TaskStatus::Completed));
  147|      1|    }
  148|       |
  149|       |    #[test]
  150|      1|    fn test_task_query_builder_task_type() {
  151|      1|        let builder = TaskQueryBuilder::new().task_type(TaskType::Project);
  152|      1|        let filters = builder.build();
  153|       |
  154|      1|        assert_eq!(filters.task_type, Some(TaskType::Project));
  155|      1|    }
  156|       |
  157|       |    #[test]
  158|      1|    fn test_task_query_builder_project_uuid() {
  159|      1|        let uuid = Uuid::new_v4();
  160|      1|        let builder = TaskQueryBuilder::new().project_uuid(uuid);
  161|      1|        let filters = builder.build();
  162|       |
  163|      1|        assert_eq!(filters.project_uuid, Some(uuid));
  164|      1|    }
  165|       |
  166|       |    #[test]
  167|      1|    fn test_task_query_builder_area_uuid() {
  168|      1|        let uuid = Uuid::new_v4();
  169|      1|        let builder = TaskQueryBuilder::new().area_uuid(uuid);
  170|      1|        let filters = builder.build();
  171|       |
  172|      1|        assert_eq!(filters.area_uuid, Some(uuid));
  173|      1|    }
  174|       |
  175|       |    #[test]
  176|      1|    fn test_task_query_builder_tags() {
  177|      1|        let tags = vec!["urgent".to_string(), "important".to_string()];
  178|      1|        let builder = TaskQueryBuilder::new().tags(tags.clone());
  179|      1|        let filters = builder.build();
  180|       |
  181|      1|        assert_eq!(filters.tags, Some(tags));
  182|      1|    }
  183|       |
  184|       |    #[test]
  185|      1|    fn test_task_query_builder_start_date_range() {
  186|      1|        let from = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
  187|      1|        let to = NaiveDate::from_ymd_opt(2024, 12, 31).unwrap();
  188|      1|        let builder = TaskQueryBuilder::new().start_date_range(Some(from), Some(to));
  189|      1|        let filters = builder.build();
  190|       |
  191|      1|        assert_eq!(filters.start_date_from, Some(from));
  192|      1|        assert_eq!(filters.start_date_to, Some(to));
  193|      1|    }
  194|       |
  195|       |    #[test]
  196|      1|    fn test_task_query_builder_deadline_range() {
  197|      1|        let from = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
  198|      1|        let to = NaiveDate::from_ymd_opt(2024, 12, 31).unwrap();
  199|      1|        let builder = TaskQueryBuilder::new().deadline_range(Some(from), Some(to));
  200|      1|        let filters = builder.build();
  201|       |
  202|      1|        assert_eq!(filters.deadline_from, Some(from));
  203|      1|        assert_eq!(filters.deadline_to, Some(to));
  204|      1|    }
  205|       |
  206|       |    #[test]
  207|      1|    fn test_task_query_builder_search() {
  208|      1|        let query = "test search";
  209|      1|        let builder = TaskQueryBuilder::new().search(query);
  210|      1|        let filters = builder.build();
  211|       |
  212|      1|        assert_eq!(filters.search_query, Some(query.to_string()));
  213|      1|    }
  214|       |
  215|       |    #[test]
  216|      1|    fn test_task_query_builder_limit() {
  217|      1|        let builder = TaskQueryBuilder::new().limit(50);
  218|      1|        let filters = builder.build();
  219|       |
  220|      1|        assert_eq!(filters.limit, Some(50));
  221|      1|    }
  222|       |
  223|       |    #[test]
  224|      1|    fn test_task_query_builder_offset() {
  225|      1|        let builder = TaskQueryBuilder::new().offset(10);
  226|      1|        let filters = builder.build();
  227|       |
  228|      1|        assert_eq!(filters.offset, Some(10));
  229|      1|    }
  230|       |
  231|       |    #[test]
  232|      1|    fn test_task_query_builder_chaining() {
  233|      1|        let uuid = Uuid::new_v4();
  234|      1|        let tags = vec!["urgent".to_string()];
  235|      1|        let from = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
  236|      1|        let to = NaiveDate::from_ymd_opt(2024, 12, 31).unwrap();
  237|       |
  238|      1|        let builder = TaskQueryBuilder::new()
  239|      1|            .status(TaskStatus::Incomplete)
  240|      1|            .task_type(TaskType::Todo)
  241|      1|            .project_uuid(uuid)
  242|      1|            .tags(tags.clone())
  243|      1|            .start_date_range(Some(from), Some(to))
  244|      1|            .search("test")
  245|      1|            .limit(25)
  246|      1|            .offset(5);
  247|       |
  248|      1|        let filters = builder.build();
  249|       |
  250|      1|        assert_eq!(filters.status, Some(TaskStatus::Incomplete));
  251|      1|        assert_eq!(filters.task_type, Some(TaskType::Todo));
  252|      1|        assert_eq!(filters.project_uuid, Some(uuid));
  253|      1|        assert_eq!(filters.tags, Some(tags));
  254|      1|        assert_eq!(filters.start_date_from, Some(from));
  255|      1|        assert_eq!(filters.start_date_to, Some(to));
  256|      1|        assert_eq!(filters.search_query, Some("test".to_string()));
  257|      1|        assert_eq!(filters.limit, Some(25));
  258|      1|        assert_eq!(filters.offset, Some(5));
  259|      1|    }
  260|       |}

/Users/garthdb/Projects/rust-things/libs/things-core/src/test_utils.rs:
    1|       |//! Test utilities and mock data for Things 3 integration
    2|       |
    3|       |use crate::models::{Area, Project, Task, TaskStatus, TaskType};
    4|       |use chrono::Utc;
    5|       |use rusqlite::Connection;
    6|       |use std::path::Path;
    7|       |use uuid::Uuid;
    8|       |
    9|       |/// Create a test database with mock data
   10|       |///
   11|       |/// # Errors
   12|       |/// Returns `ThingsError::Database` if the database cannot be created
   13|     22|pub fn create_test_database<P: AsRef<Path>>(db_path: P) -> crate::Result<Connection> {
   14|     22|    let conn = Connection::open(db_path)?;
                      ^21                             ^1
   15|       |
   16|       |    // Create the Things 3 schema
   17|     21|    conn.execute_batch(
   18|     21|        r#"
   19|     21|        -- TMTask table (main tasks table) - matches real Things 3 schema
   20|     21|        CREATE TABLE IF NOT EXISTS TMTask (
   21|     21|            uuid TEXT PRIMARY KEY,
   22|     21|            leavesTombstone INTEGER,
   23|     21|            creationDate REAL,
   24|     21|            userModificationDate REAL,
   25|     21|            type INTEGER,
   26|     21|            status INTEGER,
   27|     21|            stopDate REAL,
   28|     21|            trashed INTEGER,
   29|     21|            title TEXT,
   30|     21|            notes TEXT,
   31|     21|            notesSync INTEGER,
   32|     21|            cachedTags BLOB,
   33|     21|            start INTEGER,
   34|     21|            startDate INTEGER,
   35|     21|            startBucket INTEGER,
   36|     21|            reminderTime INTEGER,
   37|     21|            lastReminderInteractionDate REAL,
   38|     21|            deadline INTEGER,
   39|     21|            deadlineSuppressionDate INTEGER,
   40|     21|            t2_deadlineOffset INTEGER,
   41|     21|            "index" INTEGER,
   42|     21|            todayIndex INTEGER,
   43|     21|            todayIndexReferenceDate INTEGER,
   44|     21|            area TEXT,
   45|     21|            project TEXT,
   46|     21|            heading TEXT,
   47|     21|            contact TEXT,
   48|     21|            untrashedLeafActionsCount INTEGER,
   49|     21|            openUntrashedLeafActionsCount INTEGER,
   50|     21|            checklistItemsCount INTEGER,
   51|     21|            openChecklistItemsCount INTEGER,
   52|     21|            rt1_repeatingTemplate TEXT,
   53|     21|            rt1_recurrenceRule BLOB,
   54|     21|            rt1_instanceCreationStartDate INTEGER,
   55|     21|            rt1_instanceCreationPaused INTEGER,
   56|     21|            rt1_instanceCreationCount INTEGER,
   57|     21|            rt1_afterCompletionReferenceDate INTEGER,
   58|     21|            rt1_nextInstanceStartDate INTEGER,
   59|     21|            experimental BLOB,
   60|     21|            repeater BLOB,
   61|     21|            repeaterMigrationDate REAL
   62|     21|        );
   63|     21|
   64|     21|        -- TMArea table (areas)
   65|     21|        CREATE TABLE IF NOT EXISTS TMArea (
   66|     21|            uuid TEXT PRIMARY KEY,
   67|     21|            title TEXT NOT NULL,
   68|     21|            visible INTEGER,
   69|     21|            "index" INTEGER NOT NULL DEFAULT 0,
   70|     21|            cachedTags BLOB,
   71|     21|            experimental BLOB
   72|     21|        );
   73|     21|
   74|     21|        -- TMTag table (tags)
   75|     21|        CREATE TABLE IF NOT EXISTS TMTag (
   76|     21|            uuid TEXT PRIMARY KEY,
   77|     21|            title TEXT NOT NULL,
   78|     21|            created TEXT NOT NULL,
   79|     21|            modified TEXT NOT NULL,
   80|     21|            "index" INTEGER NOT NULL DEFAULT 0
   81|     21|        );
   82|     21|
   83|     21|        -- TMTaskTag table (many-to-many relationship)
   84|     21|        CREATE TABLE IF NOT EXISTS TMTaskTag (
   85|     21|            task_uuid TEXT NOT NULL,
   86|     21|            tag_uuid TEXT NOT NULL,
   87|     21|            PRIMARY KEY (task_uuid, tag_uuid)
   88|     21|        );
   89|     21|        "#,
   90|      0|    )?;
   91|       |
   92|       |    // Insert mock data
   93|     21|    insert_mock_data(&conn)?;
                                         ^0
   94|       |
   95|     21|    Ok(conn)
   96|     22|}
   97|       |
   98|       |/// Insert mock data into the test database
   99|       |#[allow(clippy::too_many_lines)]
  100|     21|fn insert_mock_data(conn: &Connection) -> crate::Result<()> {
  101|     21|    let now = Utc::now();
  102|     21|    let today = now.date_naive();
  103|     21|    let tomorrow = today + chrono::Duration::days(1);
  104|     21|    let yesterday = today - chrono::Duration::days(1);
  105|       |
  106|       |    // Insert mock areas
  107|     21|    let areas = vec![
  108|     21|        (
  109|     21|            "15c0f1a2-3b4c-5d6e-7f8a-9b0c1d2e3f4a",
  110|     21|            "Work",
  111|     21|            "Professional tasks and projects",
  112|     21|        ),
  113|     21|        (
  114|     21|            "16f2a3b4-5c6d-7e8f-9a0b-1c2d3e4f5a6b",
  115|     21|            "Personal",
  116|     21|            "Personal life and hobbies",
  117|     21|        ),
  118|     21|        (
  119|     21|            "17a3b4c5-6d7e-8f9a-0b1c-2d3e4f5a6b7c",
  120|     21|            "Health & Fitness",
  121|     21|            "Health and wellness tasks",
  122|     21|        ),
  123|       |    ];
  124|       |
  125|     84|    for (uuid, title, _notes) in areas {
                       ^63   ^63    ^63
  126|     63|        conn.execute(
  127|     63|            "INSERT INTO TMArea (uuid, title, visible, \"index\") VALUES (?, ?, ?, ?)",
  128|     63|            (
  129|     63|                uuid, title, 1, // visible = 1
  130|     63|                0, // index
  131|     63|            ),
  132|      0|        )?;
  133|       |    }
  134|       |
  135|       |    // Insert mock tags
  136|     21|    let tags = vec![
  137|     21|        ("1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d", "Urgent"),
  138|     21|        ("2b3c4d5e-6f7a-8b9c-0d1e-2f3a4b5c6d7e", "Important"),
  139|     21|        ("3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f", "Meeting"),
  140|     21|        ("4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a", "Email"),
  141|     21|        ("5e6f7a8b-9c0d-1e2f-3a4b-5c6d7e8f9a0b", "Review"),
  142|       |    ];
  143|       |
  144|    126|    for (uuid, title) in tags {
                       ^105  ^105
  145|    105|        conn.execute(
  146|    105|            "INSERT INTO TMTag (uuid, title, created, modified, \"index\") VALUES (?, ?, ?, ?, ?)",
  147|    105|            (uuid, title, now.to_rfc3339(), now.to_rfc3339(), 0),
  148|      0|        )?;
  149|       |    }
  150|       |
  151|       |    // Insert mock tasks
  152|     21|    let tasks = vec![
  153|       |        // Inbox tasks
  154|     21|        (
  155|     21|            "1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
  156|     21|            "Review quarterly reports",
  157|     21|            "Need to review Q3 financial reports before board meeting",
  158|     21|            None,
  159|     21|            Some(tomorrow),
  160|     21|            "incomplete",
  161|     21|            "to-do",
  162|     21|            None::<String>,
  163|     21|            None::<String>,
  164|     21|            None::<String>,
  165|     21|        ),
  166|     21|        (
  167|     21|            "2b3c4d5e-6f7a-8b9c-0d1e-2f3a4b5c6d7e",
  168|     21|            "Call dentist",
  169|     21|            "Schedule annual checkup",
  170|     21|            None,
  171|     21|            None,
  172|     21|            "incomplete",
  173|     21|            "to-do",
  174|     21|            None::<String>,
  175|     21|            None::<String>,
  176|     21|            None::<String>,
  177|     21|        ),
  178|     21|        (
  179|     21|            "3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f",
  180|     21|            "Buy groceries",
  181|     21|            "Milk, bread, eggs, vegetables",
  182|     21|            None,
  183|     21|            None,
  184|     21|            "incomplete",
  185|     21|            "to-do",
  186|     21|            None::<String>,
  187|     21|            None::<String>,
  188|     21|            None::<String>,
  189|     21|        ),
  190|       |        // Today's tasks
  191|     21|        (
  192|     21|            "4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a",
  193|     21|            "Team standup meeting",
  194|     21|            "Daily standup at 9 AM",
  195|     21|            Some(today),
  196|     21|            None,
  197|     21|            "incomplete",
  198|     21|            "to-do",
  199|     21|            None::<String>,
  200|     21|            None::<String>,
  201|     21|            None::<String>,
  202|     21|        ),
  203|     21|        (
  204|     21|            "5e6f7a8b-9c0d-1e2f-3a4b-5c6d7e8f9a0b",
  205|     21|            "Code review for PR #123",
  206|     21|            "Review John's changes to the authentication module",
  207|     21|            Some(today),
  208|     21|            None,
  209|     21|            "incomplete",
  210|     21|            "to-do",
  211|     21|            None::<String>,
  212|     21|            None::<String>,
  213|     21|            None::<String>,
  214|     21|        ),
  215|       |        // Projects
  216|     21|        (
  217|     21|            "6f7a8b9c-0d1e-2f3a-4b5c-6d7e8f9a0b1c",
  218|     21|            "Website Redesign",
  219|     21|            "Complete redesign of company website",
  220|     21|            Some(yesterday),
  221|     21|            Some(today + chrono::Duration::days(30)),
  222|     21|            "incomplete",
  223|     21|            "project",
  224|     21|            None,
  225|     21|            Some("15c0f1a2-3b4c-5d6e-7f8a-9b0c1d2e3f4a".to_string()),
  226|     21|            None,
  227|     21|        ),
  228|     21|        (
  229|     21|            "7a8b9c0d-1e2f-3a4b-5c6d-7e8f9a0b1c2d",
  230|     21|            "Learn Rust",
  231|     21|            "Master the Rust programming language",
  232|     21|            Some(yesterday),
  233|     21|            None,
  234|     21|            "incomplete",
  235|     21|            "project",
  236|     21|            None,
  237|     21|            Some("16f2a3b4-5c6d-7e8f-9a0b-1c2d3e4f5a6b".to_string()),
  238|     21|            None,
  239|     21|        ),
  240|       |        // Completed tasks
  241|     21|        (
  242|     21|            "8a9b0c1d-2e3f-4a5b-6c7d-8e9f0a1b2c3d",
  243|     21|            "Update documentation",
  244|     21|            "Update API documentation for new endpoints",
  245|     21|            Some(yesterday),
  246|     21|            Some(yesterday),
  247|     21|            "completed",
  248|     21|            "to-do",
  249|     21|            None,
  250|     21|            Some("15c0f1a2-3b4c-5d6e-7f8a-9b0c1d2e3f4a".to_string()),
  251|     21|            None,
  252|     21|        ),
  253|       |    ];
  254|       |
  255|       |    for (
  256|    168|        uuid,
  257|    168|        title,
  258|    168|        notes,
  259|    168|        start_date,
  260|    168|        deadline,
  261|    168|        status,
  262|    168|        task_type,
  263|    168|        project_uuid,
  264|    168|        area_uuid,
  265|    168|        parent_uuid,
  266|    189|    ) in tasks
  267|       |    {
  268|    168|        conn.execute(
  269|    168|            "INSERT INTO TMTask (uuid, title, notes, startDate, deadline, creationDate, userModificationDate, status, type, project, area, heading, \"index\") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
  270|       |            (
  271|    168|                uuid,
  272|    168|                title,
  273|    168|                notes,
  274|    168|                start_date.map(|d| {
                                                 ^105
  275|       |                    // Convert to days since 2001-01-01
  276|    105|                    let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  277|    105|                    d.signed_duration_since(base_date).num_days()
  278|    105|                }),
  279|    168|                deadline.map(|d| {
                                               ^63
  280|       |                    // Convert to days since 2001-01-01
  281|     63|                    let base_date = chrono::NaiveDate::from_ymd_opt(2001, 1, 1).unwrap();
  282|     63|                    d.signed_duration_since(base_date).num_days()
  283|     63|                }),
  284|       |                #[allow(clippy::cast_precision_loss)]
  285|       |                {
  286|    168|                    now.timestamp() as f64
  287|       |                },
  288|       |                #[allow(clippy::cast_precision_loss)]
  289|       |                {
  290|    168|                    now.timestamp() as f64
  291|       |                },
  292|    168|                match status {
  293|    168|                    "completed" => 1,
                                                 ^21
  294|    147|                    "canceled" => 2,
                                                ^0
  295|    147|                    "trashed" => 3,
                                               ^0
  296|    147|                    _ => 0,
  297|       |                },
  298|    168|                match task_type {
  299|    168|                    "project" => 1,
                                               ^42
  300|    126|                    "heading" => 2,
                                               ^0
  301|    126|                    "area" => 3,
                                            ^0
  302|    126|                    _ => 0,
  303|       |                },
  304|    168|                project_uuid,
  305|    168|                area_uuid,
  306|    168|                parent_uuid,
  307|       |                0,
  308|       |            ),
  309|      0|        )?;
  310|       |    }
  311|       |
  312|       |    // Insert task-tag relationships
  313|     21|    let task_tags = vec![
  314|     21|        ("task-1", "urgent"),
  315|     21|        ("task-1", "important"),
  316|     21|        ("task-4", "meeting"),
  317|     21|        ("task-5", "review"),
  318|     21|        ("task-6", "important"),
  319|       |    ];
  320|       |
  321|    126|    for (task_uuid, tag_uuid) in task_tags {
                       ^105       ^105
  322|    105|        conn.execute(
  323|    105|            "INSERT INTO TMTaskTag (task_uuid, tag_uuid) VALUES (?, ?)",
  324|    105|            (task_uuid, tag_uuid),
  325|      0|        )?;
  326|       |    }
  327|       |
  328|     21|    Ok(())
  329|     21|}
  330|       |
  331|       |/// Create mock data for testing
  332|       |///
  333|       |/// # Panics
  334|       |/// Panics if UUID parsing fails (should not happen with hardcoded UUIDs)
  335|       |#[must_use]
  336|     18|pub fn create_mock_tasks() -> Vec<Task> {
  337|     18|    let now = Utc::now();
  338|     18|    let today = now.date_naive();
  339|     18|    let tomorrow = today + chrono::Duration::days(1);
  340|       |
  341|     18|    vec![
  342|     18|        Task {
  343|     18|            uuid: Uuid::parse_str("550e8400-e29b-41d4-a716-446655440001").unwrap(),
  344|     18|            title: "Review quarterly reports".to_string(),
  345|     18|            notes: Some("Need to review Q3 financial reports before board meeting".to_string()),
  346|     18|            start_date: None,
  347|     18|            deadline: Some(tomorrow),
  348|     18|            created: now,
  349|     18|            modified: now,
  350|     18|            status: TaskStatus::Incomplete,
  351|     18|            task_type: TaskType::Todo,
  352|     18|            project_uuid: None,
  353|     18|            area_uuid: None,
  354|     18|            parent_uuid: None,
  355|     18|            tags: vec![],
  356|     18|            children: vec![],
  357|     18|        },
  358|     18|        Task {
  359|     18|            uuid: Uuid::parse_str("550e8400-e29b-41d4-a716-446655440002").unwrap(),
  360|     18|            title: "Call dentist".to_string(),
  361|     18|            notes: Some("Schedule annual checkup".to_string()),
  362|     18|            start_date: None,
  363|     18|            deadline: None,
  364|     18|            created: now,
  365|     18|            modified: now,
  366|     18|            status: TaskStatus::Incomplete,
  367|     18|            task_type: TaskType::Todo,
  368|     18|            project_uuid: None,
  369|     18|            area_uuid: None,
  370|     18|            parent_uuid: None,
  371|     18|            tags: vec![],
  372|     18|            children: vec![],
  373|     18|        },
  374|       |    ]
  375|     18|}
  376|       |
  377|       |/// Create mock projects for testing
  378|       |///
  379|       |/// # Panics
  380|       |/// Panics if UUID parsing fails (should not happen with hardcoded UUIDs)
  381|       |#[must_use]
  382|     14|pub fn create_mock_projects() -> Vec<Project> {
  383|     14|    let now = Utc::now();
  384|     14|    let today = now.date_naive();
  385|     14|    let deadline = today + chrono::Duration::days(30);
  386|       |
  387|     14|    vec![Project {
  388|     14|        uuid: Uuid::parse_str("550e8400-e29b-41d4-a716-446655440010").unwrap(),
  389|     14|        title: "Website Redesign".to_string(),
  390|     14|        notes: Some("Complete redesign of company website".to_string()),
  391|     14|        start_date: Some(today),
  392|     14|        deadline: Some(deadline),
  393|     14|        created: now,
  394|     14|        modified: now,
  395|     14|        area_uuid: Some(Uuid::parse_str("550e8400-e29b-41d4-a716-446655440100").unwrap()),
  396|     14|        tags: vec![],
  397|     14|        status: TaskStatus::Incomplete,
  398|     14|        tasks: vec![],
  399|     14|    }]
  400|     14|}
  401|       |
  402|       |/// Create mock areas for testing
  403|       |///
  404|       |/// # Panics
  405|       |/// Panics if UUID parsing fails (should not happen with hardcoded UUIDs)
  406|       |#[must_use]
  407|     14|pub fn create_mock_areas() -> Vec<Area> {
  408|     14|    let now = Utc::now();
  409|       |
  410|     14|    vec![
  411|     14|        Area {
  412|     14|            uuid: Uuid::parse_str("550e8400-e29b-41d4-a716-446655440100").unwrap(),
  413|     14|            title: "Work".to_string(),
  414|     14|            notes: Some("Professional tasks and projects".to_string()),
  415|     14|            created: now,
  416|     14|            modified: now,
  417|     14|            tags: vec![],
  418|     14|            projects: vec![],
  419|     14|        },
  420|     14|        Area {
  421|     14|            uuid: Uuid::parse_str("550e8400-e29b-41d4-a716-446655440101").unwrap(),
  422|     14|            title: "Personal".to_string(),
  423|     14|            notes: Some("Personal life and hobbies".to_string()),
  424|     14|            created: now,
  425|     14|            modified: now,
  426|     14|            tags: vec![],
  427|     14|            projects: vec![],
  428|     14|        },
  429|       |    ]
  430|     14|}
  431|       |
  432|       |#[cfg(test)]
  433|       |mod tests {
  434|       |    use super::*;
  435|       |    use tempfile::NamedTempFile;
  436|       |
  437|       |    #[test]
  438|      1|    fn test_create_test_database() {
  439|      1|        let temp_file = NamedTempFile::new().unwrap();
  440|      1|        let db_path = temp_file.path();
  441|       |
  442|      1|        let conn = create_test_database(db_path).unwrap();
  443|       |
  444|       |        // Test that we can query the mock data
  445|      1|        let mut stmt = conn.prepare("SELECT COUNT(*) FROM TMTask").unwrap();
  446|      1|        let count: i64 = stmt.query_row([], |row| row.get(0)).unwrap();
  447|      1|        assert!(count > 0);
  448|      1|    }
  449|       |
  450|       |    #[test]
  451|      1|    fn test_mock_data_creation() {
  452|      1|        let tasks = create_mock_tasks();
  453|      1|        assert_eq!(tasks.len(), 2);
  454|      1|        assert_eq!(tasks[0].title, "Review quarterly reports");
  455|       |
  456|      1|        let projects = create_mock_projects();
  457|      1|        assert_eq!(projects.len(), 1);
  458|      1|        assert_eq!(projects[0].title, "Website Redesign");
  459|       |
  460|      1|        let areas = create_mock_areas();
  461|      1|        assert_eq!(areas.len(), 2);
  462|      1|        assert_eq!(areas[0].title, "Work");
  463|      1|    }
  464|       |
  465|       |    #[test]
  466|      1|    fn test_create_test_database_error_handling() {
  467|       |        // Test with invalid path (should fail)
  468|      1|        let invalid_path = "/invalid/path/that/does/not/exist/database.sqlite";
  469|      1|        let result = create_test_database(invalid_path);
  470|      1|        assert!(result.is_err());
  471|      1|    }
  472|       |
  473|       |    #[test]
  474|      1|    fn test_mock_tasks_structure() {
  475|      1|        let tasks = create_mock_tasks();
  476|       |
  477|       |        // Test first task
  478|      1|        let task1 = &tasks[0];
  479|      1|        assert_eq!(task1.title, "Review quarterly reports");
  480|      1|        assert_eq!(task1.status, TaskStatus::Incomplete);
  481|      1|        assert_eq!(task1.task_type, TaskType::Todo);
  482|      1|        assert!(task1.notes.is_some());
  483|      1|        assert!(task1.deadline.is_some());
  484|      1|        assert!(task1.start_date.is_none());
  485|      1|        assert!(task1.project_uuid.is_none());
  486|      1|        assert!(task1.area_uuid.is_none());
  487|      1|        assert!(task1.parent_uuid.is_none());
  488|      1|        assert!(task1.tags.is_empty());
  489|      1|        assert!(task1.children.is_empty());
  490|       |
  491|       |        // Test second task
  492|      1|        let task2 = &tasks[1];
  493|      1|        assert_eq!(task2.title, "Call dentist");
  494|      1|        assert_eq!(task2.status, TaskStatus::Incomplete);
  495|      1|        assert_eq!(task2.task_type, TaskType::Todo);
  496|      1|        assert!(task2.notes.is_some());
  497|      1|        assert!(task2.deadline.is_none());
  498|      1|        assert!(task2.start_date.is_none());
  499|      1|        assert!(task2.project_uuid.is_none());
  500|      1|        assert!(task2.area_uuid.is_none());
  501|      1|        assert!(task2.parent_uuid.is_none());
  502|      1|        assert!(task2.tags.is_empty());
  503|      1|        assert!(task2.children.is_empty());
  504|      1|    }
  505|       |
  506|       |    #[test]
  507|      1|    fn test_mock_projects_structure() {
  508|      1|        let projects = create_mock_projects();
  509|      1|        let project = &projects[0];
  510|       |
  511|      1|        assert_eq!(project.title, "Website Redesign");
  512|      1|        assert_eq!(project.status, TaskStatus::Incomplete);
  513|      1|        assert!(project.notes.is_some());
  514|      1|        assert!(project.start_date.is_some());
  515|      1|        assert!(project.deadline.is_some());
  516|      1|        assert!(project.area_uuid.is_some());
  517|      1|        assert!(project.tags.is_empty());
  518|      1|        assert!(project.tasks.is_empty());
  519|      1|    }
  520|       |
  521|       |    #[test]
  522|      1|    fn test_mock_areas_structure() {
  523|      1|        let areas = create_mock_areas();
  524|       |
  525|       |        // Test first area
  526|      1|        let area1 = &areas[0];
  527|      1|        assert_eq!(area1.title, "Work");
  528|      1|        assert!(area1.notes.is_some());
  529|      1|        assert!(area1.tags.is_empty());
  530|      1|        assert!(area1.projects.is_empty());
  531|       |
  532|       |        // Test second area
  533|      1|        let area2 = &areas[1];
  534|      1|        assert_eq!(area2.title, "Personal");
  535|      1|        assert!(area2.notes.is_some());
  536|      1|        assert!(area2.tags.is_empty());
  537|      1|        assert!(area2.projects.is_empty());
  538|      1|    }
  539|       |
  540|       |    #[test]
  541|      1|    fn test_mock_data_timestamps() {
  542|      1|        let tasks = create_mock_tasks();
  543|      1|        let projects = create_mock_projects();
  544|      1|        let areas = create_mock_areas();
  545|       |
  546|      1|        let now = Utc::now();
  547|       |
  548|       |        // All entities should have recent timestamps
  549|      3|        for task in &tasks {
                          ^2
  550|      2|            assert!(task.created <= now);
  551|      2|            assert!(task.modified <= now);
  552|       |        }
  553|       |
  554|      2|        for project in &projects {
                          ^1
  555|      1|            assert!(project.created <= now);
  556|      1|            assert!(project.modified <= now);
  557|       |        }
  558|       |
  559|      3|        for area in &areas {
                          ^2
  560|      2|            assert!(area.created <= now);
  561|      2|            assert!(area.modified <= now);
  562|       |        }
  563|      1|    }
  564|       |
  565|       |    #[test]
  566|      1|    fn test_mock_data_uuid_parsing() {
  567|      1|        let tasks = create_mock_tasks();
  568|      1|        let projects = create_mock_projects();
  569|      1|        let areas = create_mock_areas();
  570|       |
  571|       |        // All UUIDs should be valid
  572|      3|        for task in &tasks {
                          ^2
  573|      2|            assert!(!task.uuid.is_nil());
  574|       |        }
  575|       |
  576|      2|        for project in &projects {
                          ^1
  577|      1|            assert!(!project.uuid.is_nil());
  578|      1|            if let Some(area_uuid) = project.area_uuid {
  579|      1|                assert!(!area_uuid.is_nil());
  580|      0|            }
  581|       |        }
  582|       |
  583|      3|        for area in &areas {
                          ^2
  584|      2|            assert!(!area.uuid.is_nil());
  585|       |        }
  586|      1|    }
  587|       |}

/Users/garthdb/Projects/rust-things/tools/xtask/src/main.rs:
    1|       |//! Xtask - Build and development tools for Things 3 integration
    2|       |
    3|       |use anyhow::Result;
    4|       |use clap::{Parser, Subcommand};
    5|       |use std::fs;
    6|       |use std::os::unix::fs::PermissionsExt;
    7|       |use std::path::Path;
    8|       |
    9|       |#[derive(Parser)]
   10|       |#[command(name = "xtask")]
   11|       |#[command(about = "Build and development tools for Things 3 integration")]
   12|       |#[command(version)]
   13|       |struct Cli {
   14|       |    #[command(subcommand)]
   15|       |    command: Commands,
   16|       |}
   17|       |
   18|       |#[derive(Subcommand)]
   19|       |enum Commands {
   20|       |    /// Generate test suites
   21|       |    GenerateTests {
   22|       |        /// Target to generate tests for
   23|       |        target: String,
   24|       |    },
   25|       |    /// Generate code
   26|       |    GenerateCode {
   27|       |        /// Code to generate
   28|       |        code: String,
   29|       |    },
   30|       |    /// Local development setup
   31|       |    LocalDev {
   32|       |        #[command(subcommand)]
   33|       |        action: LocalDevAction,
   34|       |    },
   35|       |    /// Things-specific operations
   36|       |    Things {
   37|       |        #[command(subcommand)]
   38|       |        action: ThingsAction,
   39|       |    },
   40|       |    /// Code analysis
   41|       |    Analyze,
   42|       |    /// Performance testing
   43|       |    PerfTest,
   44|       |    /// Setup git hooks
   45|       |    SetupHooks,
   46|       |}
   47|       |
   48|       |#[derive(Subcommand)]
   49|       |enum LocalDevAction {
   50|       |    /// Set up local development environment
   51|       |    Setup,
   52|       |    /// Health check
   53|       |    Health,
   54|       |    /// Clean build artifacts
   55|       |    Clean,
   56|       |}
   57|       |
   58|       |#[derive(Subcommand)]
   59|       |enum ThingsAction {
   60|       |    /// Validate Things database
   61|       |    Validate,
   62|       |    /// Backup Things database
   63|       |    Backup,
   64|       |    /// Show database location
   65|       |    DbLocation,
   66|       |}
   67|       |
   68|      0|fn main() -> Result<()> {
   69|      0|    let cli = Cli::parse();
   70|       |
   71|      0|    match cli.command {
   72|      0|        Commands::GenerateTests { target } => {
   73|      0|            generate_tests(&target);
   74|      0|        }
   75|      0|        Commands::GenerateCode { code } => {
   76|      0|            generate_code(&code);
   77|      0|        }
   78|      0|        Commands::LocalDev { action } => match action {
   79|      0|            LocalDevAction::Setup => {
   80|      0|                local_dev_setup();
   81|      0|            }
   82|      0|            LocalDevAction::Health => {
   83|      0|                local_dev_health();
   84|      0|            }
   85|      0|            LocalDevAction::Clean => {
   86|      0|                local_dev_clean();
   87|      0|            }
   88|       |        },
   89|      0|        Commands::Things { action } => match action {
   90|      0|            ThingsAction::Validate => {
   91|      0|                things_validate();
   92|      0|            }
   93|      0|            ThingsAction::Backup => {
   94|      0|                things_backup();
   95|      0|            }
   96|      0|            ThingsAction::DbLocation => {
   97|      0|                things_db_location();
   98|      0|            }
   99|       |        },
  100|      0|        Commands::Analyze => {
  101|      0|            analyze();
  102|      0|        }
  103|      0|        Commands::PerfTest => {
  104|      0|            perf_test();
  105|      0|        }
  106|       |        Commands::SetupHooks => {
  107|      0|            setup_git_hooks()?;
  108|       |        }
  109|       |    }
  110|       |
  111|      0|    Ok(())
  112|      0|}
  113|       |
  114|      1|fn generate_tests(target: &str) {
  115|      1|    println!("ðŸ”§ Generating test suite for: {target}");
  116|      1|    println!("ðŸ“ This will create comprehensive unit tests");
  117|      1|    println!("âœ… Test generation complete!");
  118|      1|}
  119|       |
  120|      1|fn generate_code(code: &str) {
  121|      1|    println!("ðŸ”§ Generating code: {code}");
  122|      1|    println!("ðŸ“ This will create the requested code");
  123|      1|    println!("âœ… Code generation complete!");
  124|      1|}
  125|       |
  126|      1|fn local_dev_setup() {
  127|      1|    println!("ðŸš€ Setting up local development environment...");
  128|      1|    println!("ðŸ“¦ Installing dependencies...");
  129|      1|    println!("ðŸ”§ Configuring tools...");
  130|      1|    println!("âœ… Local development setup complete!");
  131|      1|}
  132|       |
  133|      1|fn local_dev_health() {
  134|      1|    println!("ðŸ” Running health check...");
  135|      1|    println!("âœ… All systems healthy!");
  136|      1|}
  137|       |
  138|      1|fn local_dev_clean() {
  139|      1|    println!("ðŸ§¹ Cleaning build artifacts...");
  140|      1|    println!("âœ… Cleanup complete!");
  141|      1|}
  142|       |
  143|      1|fn things_validate() {
  144|      1|    println!("ðŸ” Validating Things database...");
  145|      1|    println!("âœ… Database validation complete!");
  146|      1|}
  147|       |
  148|      1|fn things_backup() {
  149|      1|    println!("ðŸ’¾ Backing up Things database...");
  150|      1|    println!("âœ… Backup complete!");
  151|      1|}
  152|       |
  153|      1|fn things_db_location() {
  154|      1|    let home = std::env::var("HOME").unwrap_or_else(|_| "~".to_string());
                                                                      ^0  ^0
  155|      1|    let db_path = format!(
  156|      1|        "{home}/Library/Group Containers/JLMPQHK86H.com.culturedcode.ThingsMac/ThingsData-0Z0Z2/Things Database.thingsdatabase/main.sqlite"
  157|       |    );
  158|      1|    println!("ðŸ“ Things database location: {db_path}");
  159|      1|}
  160|       |
  161|      1|fn analyze() {
  162|      1|    println!("ðŸ” Running code analysis...");
  163|      1|    println!("âœ… Analysis complete!");
  164|      1|}
  165|       |
  166|      1|fn perf_test() {
  167|      1|    println!("âš¡ Running performance tests...");
  168|      1|    println!("âœ… Performance tests complete!");
  169|      1|}
  170|       |
  171|      1|fn setup_git_hooks() -> Result<()> {
  172|      1|    println!("ðŸ”§ Setting up git hooks...");
  173|       |
  174|       |    // Create .git/hooks directory if it doesn't exist
  175|      1|    let hooks_dir = Path::new(".git/hooks");
  176|      1|    if !hooks_dir.exists() {
  177|      0|        fs::create_dir_all(hooks_dir)?;
  178|      1|    }
  179|       |
  180|       |    // Create pre-commit hook
  181|      1|    let pre_commit_hook = r#"#!/bin/bash
  182|      1|# Pre-commit hook for Rust Things project
  183|      1|
  184|      1|echo "ðŸ” Running pre-commit checks..."
  185|      1|
  186|      1|# Format code
  187|      1|echo "ðŸ“ Formatting code..."
  188|      1|cargo fmt --all
  189|      1|if [ $? -ne 0 ]; then
  190|      1|    echo "âŒ Code formatting failed"
  191|      1|    exit 1
  192|      1|fi
  193|      1|
  194|      1|# Run clippy with pedantic lints
  195|      1|echo "ðŸ” Running clippy..."
  196|      1|cargo clippy --all-targets --all-features -- -D warnings -D clippy::pedantic -A clippy::missing_docs_in_private_items -A clippy::module_name_repetitions
  197|      1|if [ $? -ne 0 ]; then
  198|      1|    echo "âŒ Clippy checks failed"
  199|      1|    exit 1
  200|      1|fi
  201|      1|
  202|      1|# Run tests
  203|      1|echo "ðŸ§ª Running tests..."
  204|      1|cargo test --all-features
  205|      1|if [ $? -ne 0 ]; then
  206|      1|    echo "âŒ Tests failed"
  207|      1|    exit 1
  208|      1|fi
  209|      1|
  210|      1|echo "âœ… All pre-commit checks passed!"
  211|      1|"#;
  212|       |
  213|      1|    let pre_commit_path = hooks_dir.join("pre-commit");
  214|      1|    fs::write(&pre_commit_path, pre_commit_hook)?;
                                                              ^0
  215|       |
  216|       |    // Make the hook executable
  217|      1|    let mut perms = fs::metadata(&pre_commit_path)?.permissions();
                                                                ^0
  218|      1|    perms.set_mode(0o755);
  219|      1|    fs::set_permissions(&pre_commit_path, perms)?;
                                                              ^0
  220|       |
  221|       |    // Create pre-push hook
  222|      1|    let pre_push_hook = r#"#!/bin/bash
  223|      1|# Pre-push hook for Rust Things project
  224|      1|
  225|      1|echo "ðŸ” Running pre-push checks..."
  226|      1|
  227|      1|# Run clippy with pedantic lints
  228|      1|echo "ðŸ” Running clippy..."
  229|      1|cargo clippy --all-targets --all-features -- -D warnings -D clippy::pedantic -A clippy::missing_docs_in_private_items -A clippy::module_name_repetitions
  230|      1|if [ $? -ne 0 ]; then
  231|      1|    echo "âŒ Clippy checks failed"
  232|      1|    exit 1
  233|      1|fi
  234|      1|
  235|      1|# Run tests
  236|      1|echo "ðŸ§ª Running tests..."
  237|      1|cargo test --all-features
  238|      1|if [ $? -ne 0 ]; then
  239|      1|    echo "âŒ Tests failed"
  240|      1|    exit 1
  241|      1|fi
  242|      1|
  243|      1|echo "âœ… All pre-push checks passed!"
  244|      1|"#;
  245|       |
  246|      1|    let pre_push_path = hooks_dir.join("pre-push");
  247|      1|    fs::write(&pre_push_path, pre_push_hook)?;
                                                          ^0
  248|       |
  249|       |    // Make the hook executable
  250|      1|    let mut perms = fs::metadata(&pre_push_path)?.permissions();
                                                              ^0
  251|      1|    perms.set_mode(0o755);
  252|      1|    fs::set_permissions(&pre_push_path, perms)?;
                                                            ^0
  253|       |
  254|      1|    println!("âœ… Git hooks installed successfully!");
  255|      1|    println!("ðŸ“ Pre-commit hook: .git/hooks/pre-commit");
  256|      1|    println!("ðŸ“ Pre-push hook: .git/hooks/pre-push");
  257|      1|    println!();
  258|      1|    println!("The hooks will run:");
  259|      1|    println!("  â€¢ cargo fmt --all");
  260|      1|    println!("  â€¢ cargo clippy --all-targets --all-features -- -D warnings -D clippy::pedantic");
  261|      1|    println!("  â€¢ cargo test --all-features");
  262|       |
  263|      1|    Ok(())
  264|      1|}
  265|       |
  266|       |#[cfg(test)]
  267|       |mod tests {
  268|       |    use super::*;
  269|       |    use clap::Parser;
  270|       |
  271|       |    #[test]
  272|      1|    fn test_cli_parsing() {
  273|       |        // Test that CLI can be parsed without panicking
  274|      1|        let cli = Cli::try_parse_from(["xtask", "analyze"]).unwrap();
  275|      1|        assert!(matches!(cli.command, Commands::Analyze));
                              ^0
  276|       |
  277|      1|        let cli = Cli::try_parse_from(["xtask", "perf-test"]).unwrap();
  278|      1|        assert!(matches!(cli.command, Commands::PerfTest));
                              ^0
  279|       |
  280|      1|        let cli = Cli::try_parse_from(["xtask", "setup-hooks"]).unwrap();
  281|      1|        assert!(matches!(cli.command, Commands::SetupHooks));
                              ^0
  282|      1|    }
  283|       |
  284|       |    #[test]
  285|      1|    fn test_generate_tests_command() {
  286|      1|        let cli = Cli::try_parse_from(["xtask", "generate-tests", "things-core"]).unwrap();
  287|      1|        if let Commands::GenerateTests { target } = cli.command {
  288|      1|            assert_eq!(target, "things-core");
  289|       |        } else {
  290|      0|            panic!("Expected GenerateTests command");
  291|       |        }
  292|      1|    }
  293|       |
  294|       |    #[test]
  295|      1|    fn test_generate_code_command() {
  296|      1|        let cli = Cli::try_parse_from(["xtask", "generate-code", "test"]).unwrap();
  297|      1|        if let Commands::GenerateCode { code } = cli.command {
  298|      1|            assert_eq!(code, "test");
  299|       |        } else {
  300|      0|            panic!("Expected GenerateCode command");
  301|       |        }
  302|      1|    }
  303|       |
  304|       |    #[test]
  305|      1|    fn test_local_dev_commands() {
  306|      1|        let cli = Cli::try_parse_from(["xtask", "local-dev", "setup"]).unwrap();
  307|      1|        if let Commands::LocalDev { action } = cli.command {
  308|      1|            assert!(matches!(action, LocalDevAction::Setup));
                                  ^0
  309|       |        } else {
  310|      0|            panic!("Expected LocalDev command");
  311|       |        }
  312|       |
  313|      1|        let cli = Cli::try_parse_from(["xtask", "local-dev", "health"]).unwrap();
  314|      1|        if let Commands::LocalDev { action } = cli.command {
  315|      1|            assert!(matches!(action, LocalDevAction::Health));
                                  ^0
  316|       |        } else {
  317|      0|            panic!("Expected LocalDev command");
  318|       |        }
  319|       |
  320|      1|        let cli = Cli::try_parse_from(["xtask", "local-dev", "clean"]).unwrap();
  321|      1|        if let Commands::LocalDev { action } = cli.command {
  322|      1|            assert!(matches!(action, LocalDevAction::Clean));
                                  ^0
  323|       |        } else {
  324|      0|            panic!("Expected LocalDev command");
  325|       |        }
  326|      1|    }
  327|       |
  328|       |    #[test]
  329|      1|    fn test_things_commands() {
  330|      1|        let cli = Cli::try_parse_from(["xtask", "things", "validate"]).unwrap();
  331|      1|        if let Commands::Things { action } = cli.command {
  332|      1|            assert!(matches!(action, ThingsAction::Validate));
                                  ^0
  333|       |        } else {
  334|      0|            panic!("Expected Things command");
  335|       |        }
  336|       |
  337|      1|        let cli = Cli::try_parse_from(["xtask", "things", "backup"]).unwrap();
  338|      1|        if let Commands::Things { action } = cli.command {
  339|      1|            assert!(matches!(action, ThingsAction::Backup));
                                  ^0
  340|       |        } else {
  341|      0|            panic!("Expected Things command");
  342|       |        }
  343|       |
  344|      1|        let cli = Cli::try_parse_from(["xtask", "things", "db-location"]).unwrap();
  345|      1|        if let Commands::Things { action } = cli.command {
  346|      1|            assert!(matches!(action, ThingsAction::DbLocation));
                                  ^0
  347|       |        } else {
  348|      0|            panic!("Expected Things command");
  349|       |        }
  350|      1|    }
  351|       |
  352|       |    #[test]
  353|      1|    fn test_generate_tests_function() {
  354|       |        // Test that the function doesn't panic
  355|      1|        generate_tests("test-target");
  356|      1|    }
  357|       |
  358|       |    #[test]
  359|      1|    fn test_generate_code_function() {
  360|       |        // Test that the function doesn't panic
  361|      1|        generate_code("test-code");
  362|      1|    }
  363|       |
  364|       |    #[test]
  365|      1|    fn test_local_dev_setup_function() {
  366|       |        // Test that the function doesn't panic
  367|      1|        local_dev_setup();
  368|      1|    }
  369|       |
  370|       |    #[test]
  371|      1|    fn test_local_dev_health_function() {
  372|       |        // Test that the function doesn't panic
  373|      1|        local_dev_health();
  374|      1|    }
  375|       |
  376|       |    #[test]
  377|      1|    fn test_local_dev_clean_function() {
  378|       |        // Test that the function doesn't panic
  379|      1|        local_dev_clean();
  380|      1|    }
  381|       |
  382|       |    #[test]
  383|      1|    fn test_things_validate_function() {
  384|       |        // Test that the function doesn't panic
  385|      1|        things_validate();
  386|      1|    }
  387|       |
  388|       |    #[test]
  389|      1|    fn test_things_backup_function() {
  390|       |        // Test that the function doesn't panic
  391|      1|        things_backup();
  392|      1|    }
  393|       |
  394|       |    #[test]
  395|      1|    fn test_things_db_location_function() {
  396|       |        // Test that the function doesn't panic
  397|      1|        things_db_location();
  398|      1|    }
  399|       |
  400|       |    #[test]
  401|      1|    fn test_analyze_function() {
  402|       |        // Test that the function doesn't panic
  403|      1|        analyze();
  404|      1|    }
  405|       |
  406|       |    #[test]
  407|      1|    fn test_perf_test_function() {
  408|       |        // Test that the function doesn't panic
  409|      1|        perf_test();
  410|      1|    }
  411|       |
  412|       |    #[test]
  413|      1|    fn test_setup_git_hooks_function() {
  414|       |        // Test that the function works with a temporary directory
  415|      1|        let temp_dir = tempfile::tempdir().unwrap();
  416|      1|        let original_dir = std::env::current_dir().unwrap();
  417|       |
  418|       |        // Change to temp directory
  419|      1|        std::env::set_current_dir(temp_dir.path()).unwrap();
  420|       |
  421|       |        // Create .git directory
  422|      1|        std::fs::create_dir_all(".git/hooks").unwrap();
  423|       |
  424|       |        // Test the function
  425|      1|        let result = setup_git_hooks();
  426|      1|        assert!(result.is_ok());
  427|       |
  428|       |        // Verify hooks were created
  429|      1|        assert!(std::path::Path::new(".git/hooks/pre-commit").exists());
  430|      1|        assert!(std::path::Path::new(".git/hooks/pre-push").exists());
  431|       |
  432|       |        // Restore original directory
  433|      1|        std::env::set_current_dir(original_dir).unwrap();
  434|      1|    }
  435|       |}